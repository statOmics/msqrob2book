# The macrophage use case: a  MaxQuant LFQ DDA dataset with repeated measures{#sec-macrophages}

## Introduction

TODO write section

## Load packages

First, we load the `msqrob2` package.

```{r}
library("msqrob2")
```

We also load additional packages for data manipulation and
visualisation.

```{r}
library("dplyr")
library("ggplot2")
library("patchwork")
library("ggrepel")
```

`msqrob2` relies on parallelisation to improve computational speed.
To ensure this vignette can be run regardless of hardware, we will
disable parallelisation. Parallelisation is controlled using the
`BiocParallel` package.

```{r}
library("BiocParallel")
register(SerialParam())
```

## Data

**TODO** write section

### PSM table

```{r}
library("BiocFileCache")
bfc <- BiocFileCache()
evidenceFile <- bfcrpath(bfc, "https://ftp.pride.ebi.ac.uk/pride/data/archive/2018/05/PXD008726/evidence.txt")
```

```{r}
mouse <- data.table::fread(evidenceFile, check.names = TRUE)
```

### Sample annotation table

We extract the sample annotations from the
sample names. This is not good practices, and the code below is rather
complex. A better approach would have been to provide an annotation
table with each row corresponding to a sample and each column
corresponding to an annotation.

```{r}
coldata <- data.frame(runCol = unique(mouse$Raw.file)) |> 
    mutate(
        sampleId = gsub("^.*macr_|biol_repl", "", runCol),
        sampleId = sub("(KO|WT)_(\\d)$", "\\1_NS_0h_\\2", sampleId)) |> 
    separate(sampleId, c("genotype", "stimulation", "time", "replicate")) |> 
    mutate(
        mouse_id = paste0(genotype, "_", replicate),
        condition = paste0(genotype, "_", stimulation, "_", time)
    )
```

### Convert to QFeatures

```{r}
(mouse <- readQFeatures(
    mouse, coldata, quantCols = "Intensity", runCol = "Raw.file"
))
```

We now have a `QFeatures` object with 30 sets, each containing data
associated with an MS run.

## Data preprocessing

`msqrob2` relies on the `QFeatures` data structure, meaning that we
can directly make use of `QFeatures`' data preprocessing
functionality. We will not detail the usage of each function below, but
instead refer to the `QFeatures`
[documentation](https://rformassspectrometry.github.io/QFeatures/articles/Processing.html).

### Encode missing values

Next, we convert zero intensities to NA.

```{r}
mouse <- zeroIsNA(mouse, names(mouse))
```

### Log2 transformation

```{r}
inputNames <- names(mouse)
logNames <- paste0(inputNames, "_log")
mouse <- logTransform(mouse, inputNames, name = logNames, base = 2)
```

### PSM filtering

[Remember](#sec-preprocess_evidence) that when starting from the
evidence file, the data from every run is contained in a separate set
and we need to define a feature identifier that is shared across runs.
We will here create an `ionID`, that is the combined peptide sequence
and charge. The issue is that MaxQuant returns multiple PSM for some
ions, so we select only the PSM with the highest intensity (see
[here](#sec-duplicated_psms) for a step-by-step explanation of the
code). Once the duplicated PSMs per ion are filtered out, we can join
the data in a single set

```{r}
for (i in logNames) {
    rowdata <- rowData(mouse[[i]]) 
    rowdata$ionID <- paste0(rowdata$Sequence, rowdata$Charge) 
    rowdata$value <- assay(mouse[[i]])[, 1]
    rowdata <- data.frame(rowdata) |>
        group_by(ionID) |>
        mutate(psmRank = rank(-value))
    rowData(mouse[[i]])$psmRank <- rowdata$psmRank
    rowData(mouse[[i]])$ionID <- rowdata$ionID
}
mouse <- filterFeatures(mouse, ~ psmRank == 1, keep = TRUE)
mouse <- joinAssays(mouse, logNames, "ions_log", "ionID")
```

We next remove PSMs that:

1. Could not be mapped to a protein, that is PSMs that have an empty 
protein identifier
2. Map to multiple proteins (the protein identifier contains multiple
identifiers separated by a `;`)
3. Were identified as potential contaminant. These are flagged by 
MaxQuant with a `"+"`.
4. Match decoy (reversed) peptides. These are flagged by 
MaxQuant with a `"+"`.

```{r}
mouse <- filterFeatures(
    mouse, ~ Proteins != "" & ## 1.
        !grepl(";", Proteins) & ## 2.
        Potential.contaminant != "+" & ## 3.
        Reverse != "+" ## 4.
) 
```

We finally remove ions with too many missing 
values. Below we plot the distribution of the proportion of missing 
values at the ion level.

```{r}
missingness_ion <- nNA(mouse, "ions_log")$nNArows$pNA
hist(missingness_ion)
```

We will remove ions that are missing more than 80 % (24 out of the 30 
samples).

```{r}
mouse <- filterNA(mouse, pNA = 0.8, i = "ions_log")
```

### Normalisation

Samples are normalised using the quantile normalisation as performed 
in the original study.

```{r}
mouse <- normalize(
    mouse, "ions_log", name = "ions_norm", method = "quantiles"
)
```

### Summarisation

PSMs intensities are summarised into protein abundance values.

```{r}
mouse <- aggregateFeatures(
    mouse, i = "ions_norm", 
    name = "proteins",
    fcol = "Proteins", fun = MsCoreUtils::robustSummary
)
```

## Data exploration

**TODO**: write section 

```{r}
library("scater")
se <- getWithColData(mouse, "proteins")
se <- runMDS(as(se, "SingleCellExperiment"), exprs_values = 1)
```

We can now explore the data structure while coloring for the factor of
interest, here `condition`.

```{r, fig.width=6, fig.height=5}
plotMDS(se, colour_by = "genotype") +
    plotMDS(se, colour_by = "stimulation") +
    plotMDS(se, colour_by = "time") +
    plotMDS(se, colour_by = "mouse_id")
```


**TODO** write interpretation

## Statistical modelling

The preprocessed data can now be modelled to answer biologically
relevant questions.

### Model definition

Samples (bone marrow-derived macrophages) originate from 6 mice that
were either A20 knockouts (KO, n = 3) or wild type (WT, n = 3).
Macrophages were extracted and either stimulated with LPS, TNF or not
stimulated (NS). Moreover, the stimulation was either conducted for 1h
or for 6h.

```{r}
table(
    Genotype = mouse$genotype, stimulation = mouse$stimulation, 
    time = mouse$time
)
```

Besides the experimental, we must further identify the potential 
source of variation that should be included in the model: 

1. **Biological replication effects**: the experiment involves 
biological replication as the macrophages were sampled from 6 mice.
We expect that intensities from the same mouse are more alike than
intensities between mice. We will therefore address this
correlation with a random effect for biological replicate.

```{r}
table(mouse$mouse_id)
```

2. **Ion effects**: we will directly estimate the treatment effect at
the protein-level from ion-level data, inducing an additional
levels of correlation. The intensities of a ion will be more
similar intensities between ions. We therefore need to add a random
effect term to account for the within ion correlation structure.

3. **Sample effects**: modelling the data at the ion-level implies 
that a sample contains multiple ion intensities for each protein.
Hence, ion intensities for a protein within a sample will be more
alike than ion intensities for the same protein across different
samples. We will address this correlation with a random sample
effect.

Note that when modelling the data at the protein-level (upon 
summarisation), the ion effects and sample effects are averaged in
the protein summaries and are no longer available for modelling. It is
therefore important to use a suitable summarisation approach that can
account for these effects [Sticker et al.
2020](https://doi.org/10.1074/mcp.RA119.001624).

Now we have identified the sources of variation, we can define a
model. 

TODO: I need to discuss the model. The paper states: "For each
protein, we tested for differential abundance between genotypes (A20
KO vs WT BMDMs) at baseline, after 1 or 6 h of LPS or TNF treatment."
I don't think the data allows for this as the control group is not
matched in time... For the moment I combined all experimental variable
in a single variable "condition"

```{r}
model <- ~ 0 + condition + ## fixed effect with interaction between stimulation and genotype
    (1 | mouse_id) + ## (1) random effect for biological replicate
    (1 | ion_id) + ## (2) random effect for ion
    (1 | sample_id) ## (3) random effect for sample
```

Note, that we use an encoding without intercept `~ 0 +`. This makes it
more straightforward to define contrasts for a model with a one-way
ANOVA design for the fixed effects. Indeed, by suppressing the
intercept, a model parameters is estimated for each condition.
Otherwise, `msqrob2` selects one of the conditions as the reference
group, for which its model parameter is absorbed in the intercept. Now
we have defined the models, we can run the `msqrob2` statistical
analysis workflow.

### Statistical workflow

#### Fitting the model

The statistical workflow starts with `msqrobAggregate()`. The function
takes the `QFeatures` object, extracts the quantitative values from
the `"ions_norm"` set generated after preprocessing, and fits
`model`. The variables defined in `model` are automatically
retrieved from the `colData` (i.e. `"genotype"`, `"stimulation"`, `"mouse_id"`, `"mouse_id"`) and
from the `rowData` (i.e. `"ion_id"`). Moreover, we tell the function how the ion-level data is
grouped to protein data through the `fcol` argument, here we will
group ions by the `Proteins` variable. The function will generate a
new set, `proteins_msqrob`, with summarised protein values. This new
set will also contain the modelling output, stored in the `rowData` in
the `msqrob_psm` column. More specifically, the modelling
output is stored in the `rowData` for each protein as a `statModel`
object, one model per row (protein). We also enable M-estimation
(`robust = TRUE`) for improved robustness against outliers and ridge
penalisation (`ridge = TRUE`) to stabilise the parameter estimation.

```{r}
mouse <- msqrobAggregate(
    mouse, i = "ions_norm",
    formula = model,
    fcol = "Proteins",
    modelColumnName = "msqrob_model",
    name = "proteins_msqrob",
    ridge = TRUE, robust = TRUE
)
```

Once the models are estimated, we can start answering biological
questions.

#### Defining contrasts 

There are several biological questions we want to answer, namely what
proteins are differentially abundant between WT and KO:

1. At baseline (no stimulation)?
2. Upon 1h of LPS stimulation?
3. Upon 1h of TNF stimulation?
4. Upon 6h of LPS stimulation?
5. Upon 6h of TNF stimulation?

They need to be converted in a combination of the models parameters
that were fit in the previous step. Each combination of parameters is
called a contrast. Below are the different parameter names that where 
estimated across the data set.

```{r}
(param_names <- getCoefNames(mouse, i = "proteins_msqrob", "msqrob_model"))
```

To aid defining contrasts, we will visualise the experimental design
using the `ExploreModelMatrix` package. Since we are not interested in
technical effects, we will only focus on the variables of interest,
here `stimulation` and `genotype`.

```{r, fig.width=5, fig.height=12}
library("ExploreModelMatrix")
vd <- VisualizeDesign(
    sampleData =  colData(mouse),
    designFormula = ~ 0 + condition,
    textSizeFitted = 4
)
vd$plotlist[[1]]
```

So answering the first question, that is "which proteins are
differentially abundant between WT and KO without stimulation?", boils
down to assessing the difference between `conditionWT_NS_0h` and
`conditionKO_NS_0h`, hence the contrast starts with `conditionWT_NS_0h
- conditionKO_NS_0h`. Note that because we used ridge regression for
modelling, we need to prefix the parameter names with `ridge`. We can
further specify the contrast by setting that the difference equals to
zero. This means that our null hypothesis is that there is no
difference between the two groups. We apply the same approach for the
other research questions, and store all the contrasts in a vector.

```{r}
contrasts <- c(
    "ridgeconditionWT_NS_0h - ridgeconditionKO_NS_0h = 0", ## research question 1
    "ridgeconditionWT_LPS_1h - ridgeconditionKO_LPS_1h = 0", ## research question 2
    "ridgeconditionWT_TNF_1h - ridgeconditionKO_TNF_1h = 0", ## research question 3
    "ridgeconditionWT_LPS_6h - ridgeconditionKO_LPS_6h = 0", ## research question 4
    "ridgeconditionWT_TNF_6h - ridgeconditionKO_TNF_6h = 0" ## research question 5
)
```

We next use `makeContrast()` to build a contrast matrix from our 
contrast equations. Each column in the matrix contains one of the
contrast.

```{r}
L <- makeContrast(
    contrasts,
    parameterNames = param_names
)
```

#### Hypothesis testing

We can now test our null hypotheses using `hypothesisTest()` which
takes the `QFeatures` object with the fitted model and the contrast
matrix we just built. Again, the results are stored in the set
containing the model, here `proteins_msqrob`

```{r}
mouse <- hypothesisTest(
    mouse, i = "proteins_msqrob", L, modelColumn = "msqrob_model"
)
```

Let us retrieve the result table for the first contrast from the 
`rowData`. Note that the model column is named after the column name 
of the contrast matrix `L`.

```{r}
c1 <- colnames(L)[[1]]
inference <- rowData(mouse[["proteins_msqrob"]])[[c1]]
inference$Protein <- rownames(inference)
inference$Gene <- rowData(mouse[["proteins_msqrob"]])[["Gene.names"]]
```

#### Exploring the result

The table contains the hypothesis testing results for every protein.
Notice that some rows contain missing values. This is because data
modelling resulted in a `fitError` for some proteins. We refer to
[another
vignette](https://github.com/statOmics/Msqrob2TMTPaper/blob/master/vignettes/spikein1.qmd)
that describes how to deal with `fitErrors`. We can use the table
above directly to build a volcano plot using `ggplot2` functionality.

```{r}
ggplot(inference) +
    aes(x = logFC, y = -log10(adjPval)) +
    geom_hline(yintercept = -log10(0.05)) +
    geom_text_repel(data = filter(inference, adjPval < 0.05),
                    aes(label = Protein)) +
    geom_point() +
    ggtitle("Statistical inference on differences between LF and HF (short duration)",
            paste("Hypothesis test:", gsub("ridgecondition", "", colnames(L)), "= 0"))
```

TODO write section upon discussion

```{r}
subsetByColData(mouse, mouse$stimulation == "NS") |> 
    detailPlot("P41216", i = "ions_norm", colourVar = "condition") ## Acsl1
```

```{r}
plotOverdispersion(mouse, "proteins_msqrob", ".n", "msqrob_model")
```

## Protein level analysis

TODO needed? 

## Conclusion 

TODO write section 
