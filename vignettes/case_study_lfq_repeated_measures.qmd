---
title: "Case study: analyzing repeated measures designs in label-free proteomics with msqrob2"
author:
    - name: Christophe Vanderaa
    - name: Stijn Vandenbulcke
    - name: Lieven Clement
format:
    pdf:
        toc: true
        toc_depth: 2
        code_folding: show
date: "`r BiocStyle::doc_date()`"
package: "`r BiocStyle::pkg_ver('msqrob2')`"
vignette: >
    %\VignetteIndexEntry{msqrob2 LFQ with repeated measures}
    %\VignetteEngine{knitr::rmarkdown}
    %\VignetteEncoding{UTF-8}
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(
    warning = FALSE,
    message = FALSE
)
```


# Introduction

TODO write section

# Load packages


First, we load the `msqrob2` package.

```{r}
library("msqrob2")
```

We also load additional packages for data manipulation and
visualisation.

```{r}
library("dplyr")
library("ggplot2")
library("ggrepel")
```

`msqrob2` relies on parallelisation to improve computational speed.
To ensure this vignette can be run regardless of hardware, we will
disable parallelisation. Parallelisation is controlled using the
`BiocParallel` package.

```{r}
library("BiocParallel")
register(SerialParam())
```

# Load data

TODO write section

```{r}
library("BiocFileCache")
bfc <- BiocFileCache()
psm_file <- bfcrpath(bfc, "https://ftp.pride.ebi.ac.uk/pride/data/archive/2018/05/PXD008726/evidence.txt")
```

```{r}
mouse <- read.delim(psm_file)
```

```{r}
(mouse <- readQFeatures(
    mouse, quantCols = "Intensity", runCol = "Raw.file"
))
```

We now have a `QFeatures` object with 30 sets, each containing data
associated with an MS run. We extract the sample annotations from the
sample names. This is not good practices, and the code below is rather
complex. A better approach would have been to provide an annotation
table with each row corresponding to a sample and each column
corresponding to an annotation.

```{r}
sample_names <- unlist(colnames(mouse)) |> 
    sub(pattern = "^.*macr_", replacement = "") |> 
    sub(pattern = "biol_repl", replacement = "")
annotations <- sample_names |>
    sub(pattern = "(KO|WT)_(\\d)$", replacement = "\\1_NS_0h_\\2") |> 
    strsplit("[.]|_") |> 
    do.call(what = rbind) |> 
    data.frame()
colnames(annotations) <- c("genotype", "stimulation", "time", "mouse_id")
annotations$sample_id <- sample_names
annotations <- annotations |> 
    mutate(mouse_id = paste0(genotype, "_", mouse_id)) |> 
    mutate(condition = paste0(genotype, "_", stimulation, "_", time))
```

Once the annotation table created, we add it to the `QFeatures`
object, in the `colData` slot.

```{r}
(colData(mouse) <- annotations)
```

# Data preprocessing

`msqrob2` relies on the `QFeatures` data structure, meaning that we
can directly make use of `QFeatures`' data preprocessing
functionality. We will not detail the usage of each function below, but
instead refer to the `QFeatures`
[documentation](https://rformassspectrometry.github.io/QFeatures/articles/Processing.html).

## PSM filtering

We remove PSMs that:

1. Could not be mapped to a protein, that is PSMs that have an empty 
   protein identifier
2. Map to multiple proteins (the protein identifier contains multiple
   identifiers separated by a `;`)
3. Were identified as potential contaminant. These are flagged by 
   MaxQuant with a `"+"`.
4. Match decoy (reversed) peptides. These are flagged by 
   MaxQuant with a `"+"`.

```{r}
mouse <- filterFeatures(
    mouse, ~ Proteins != "" & ## 1.
        !grepl(";", Proteins) & ## 2.
        Potential.contaminant != "+" & ## 3.
        Reverse != "+" ## 4.
) 
```

Next, we convert zero intensities to NA.

```{r}
mouse <- zeroIsNA(mouse, names(mouse))
```

Peptide ions that were identified with multiple PSMs in a run are
collapsed to the PSM with the highest intensity.

We therefore

1. Make a new variable, `ion_id`, in the rowData by combining the
   peptide sequence and the precursor charge.
2. Use the intensity to rank the PSMs.
4. Make a new variable `rank` that ranks the PSMs for each ion 
   identifier based on the intensity.
4. We store the new information back in the `rowData`.
5. For each ion that maps to multiple PSMs, only keep the PSM with the
   highest summed intensity, that is that ranks first.

```{r}
for (i in names(mouse)) {
    rowdata <- rowData(mouse[[i]])
    rowdata$ion_id <- paste0(rowdata$Sequence, rowdata$Charge) ## 1.
    rowdata$intensity = assay(mouse[[i]])[, 1] ## 2.
    rowdata <- data.frame(rowdata) |>
        group_by(ion_id) |>
        mutate(psm_rank = rank(-intensity)) ## 3.
    rowData(mouse[[i]]) <- DataFrame(rowdata) ## 4.
}
mouse <- filterFeatures(mouse, ~ !is.na(psm_rank) & psm_rank == 1) ## 5.
```

## Preprocessing workflow

We can now prepare the data for modelling. The workflow ensure the 
data complies to `msqrob2`'s requirements:

1. Intensities are log-transformed.
2. Samples are normalised. We here use quantile normalisation as
   performed in the original study.
3. (optionally) PSMs intensities are summarised into protein abundance
   values for protein-level workflows.

```{r}
sample_names <- names(mouse)
mouse <- logTransform( ## 1.
    mouse, sample_names, name = paste0(sample_names, "_log"), base = 2
)
mouse <- normalize( ## 2.
    mouse, paste0(sample_names, "_log"), 
    name = paste0(sample_names, "_norm"),
    method = "quantiles"
)
mouse <- aggregateFeatures( ## 3.
    mouse, i = paste0(sample_names, "_norm"), 
    name = paste0(sample_names, "_proteins"),
    fcol = "Proteins", fun = MsCoreUtils::medianPolish,
    na.rm = TRUE
)
```

We next join the assays of the different runs

1. in a single PSM set for PSM-level models (we use the `ion_id` to 
   match PSMs across runs).
2. in single protein set for protein-level models

```{r}
mouse <- joinAssays( ## 1.
    mouse, i = paste0(sample_names, "_norm"), name = "ions_norm", 
    fcol = "ion_id"
) 
mouse <- joinAssays (## 2.
    mouse, i = paste0(sample_names, "_proteins"), name = "proteins"
)
```

We finally remove features (ions or proteins) with too many missing 
values. Below we plot the distribution of the proportion of missing 
values at the ion level ...

```{r}
missingness_ion <- nNA(mouse, "ions_norm")$nNArows$pNA
hist(missingness_ion)
```

... and at the protein level.

```{r}
missingness_protein <- nNA(mouse, "proteins")$nNArows$pNA
hist(missingness_protein)
```

We will remove ions that are missing in more than 50 % of the samples

```{r}
mouse <- filterNA(mouse, pNA = 0.5, i = c("ions_norm", "proteins"))
```

## Data exploration

TODO write section after discussion. 

```{r}
se <- getWithColData(mouse, "ions_norm")
```

```{r}
library("scater")
se <- runPCA(as(se, "SingleCellExperiment"), exprs_values = 1)
plotPCA(se, colour_by = "mouse_id")
```

```{r, eval=FALSE}
library("omicsGMF")
cv_results <- runCVGMF(
    se, exprs_values = 1,
    X = model.matrix(~ 1, colData(se)),
    family = gaussian(),
    control.alg = list(
        tol = 0.001,
        maxiter = 1000
    ),
    BPPARAM = MultiCoreParam(nworkers = 3),
    control.cv = list(nfolds = 3),
    ncomponents = c(3, 5, 10, 15, 20, 30),
    name = "cv_GMF")
metadata(ce)[["cv_GMF"]] |>
    ggplot() +
    aes(x = ncomp,
        y = dev) +
    geom_point()
se <- runGMF(se, exprs_values = 1)
plotPCA(se, colour_by = "mouse_id")
```

# Statistical modelling

The preprocessed data can now be modelled to answer biologically
relevant questions.

## Model definition

Samples (bone marrow-derived macrophages) originate from 6 mice that
were either A20 knockouts (KO, n = 3) or wild type (WT, n = 3).
Macrophages were extracted and either stimulated with LPS, TNF or not
stimulated (NS). Moreover, the stimulation was either conducted for 1h
or for 6h.

```{r}
table(
    Genotype = mouse$genotype, stimulation = mouse$stimulation, 
    time = mouse$time
)
```

Besides the experimental, we must further identify the potential 
source of variation that should be included in the model: 

1. **Biological replication effects**: the experiment involves 
   biological replication as the macrophages were sampled from 6 mice.
   We expect that intensities from the same mouse are more alike than
   intensities between mice. We will therefore address this
   correlation with a random effect for biological replicate.

```{r}
table(mouse$mouse_id)
```

2. **Ion effects**: we will directly estimate the treatment effect at
   the protein-level from ion-level data, inducing an additional
   levels of correlation. The intensities of a ion will be more
   similar intensities between ions. We therefore need to add a random
   effect term to account for the within ion correlation structure.

3. **Sample effects**: modelling the data at the ion-level implies 
   that a sample contains multiple ion intensities for each protein.
   Hence, ion intensities for a protein within a sample will be more
   alike than ion intensities for the same protein across different
   samples. We will address this correlation with a random sample
   effect.

Note that when modelling the data at the protein-level (upon 
summarisation), the ion effects and sample effects are averaged in
the protein summaries and are no longer available for modelling. It is
therefore important to use a suitable summarisation approach that can
account for these effects [Sticker et al.
2020](https://doi.org/10.1074/mcp.RA119.001624).

Now we have identified the sources of variation, we can define a
model. 

TODO: I need to discuss the model. The paper states: "For each
protein, we tested for differential abundance between genotypes (A20
KO vs WT BMDMs) at baseline, after 1 or 6 h of LPS or TNF treatment."
I don't think the data allows for this as the control group is not
matched in time... For the moment I combined all experimental variable
in a single variable "condition"

```{r}
model <- ~ 0 + condition + ## fixed effect with interaction between stimulation and genotype
    (1 | mouse_id) + ## (1) random effect for biological replicate
    (1 | ion_id) + ## (2) random effect for ion
    (1 | sample_id) ## (3) random effect for sample
```

Note, that we use an encoding without intercept `~ 0 +`. This makes it
more straightforward to define contrasts for a model with a one-way
ANOVA design for the fixed effects. Indeed, by suppressing the
intercept, a model parameters is estimated for each condition.
Otherwise, `msqrob2` selects one of the conditions as the reference
group, for which its model parameter is absorbed in the intercept. Now
we have defined the models, we can run the `msqrob2` statistical
analysis workflow.

## Statistical workflow

### Fitting the model

The statistical workflow starts with `msqrobAggregate()`. The function
takes the `QFeatures` object, extracts the quantitative values from
the `"ions_norm"` set generated after preprocessing, and fits
`model`. The variables defined in `model` are automatically
retrieved from the `colData` (i.e. `"genotype"`, `"stimulation"`, `"mouse_id"`, `"mouse_id"`) and
from the `rowData` (i.e. `"ion_id"`). Moreover, we tell the function how the ion-level data is
grouped to protein data through the `fcol` argument, here we will
group ions by the `Proteins` variable. The function will generate a
new set, `proteins_msqrob`, with summarised protein values. This new
set will also contain the modelling output, stored in the `rowData` in
the `msqrob_psm` column. More specifically, the modelling
output is stored in the `rowData` for each protein as a `statModel`
object, one model per row (protein). We also enable M-estimation
(`robust = TRUE`) for improved robustness against outliers and ridge
penalisation (`ridge = TRUE`) to stabilise the parameter estimation.

```{r}
mouse <- msqrobAggregate(
    mouse, i = "ions_norm",
    formula = model,
    fcol = "Proteins",
    modelColumnName = "msqrob_model",
    name = "proteins_msqrob",
    ridge = TRUE, robust = TRUE
)
```

Once the models are estimated, we can start answering biological
questions.

### Defining contrasts 

There are several biological questions we want to answer, namely what
proteins are differentially abundant between WT and KO:

1. At baseline (no stimulation)?
2. Upon 1h of LPS stimulation?
3. Upon 1h of TNF stimulation?
4. Upon 6h of LPS stimulation?
5. Upon 6h of TNF stimulation?

They need to be converted in a combination of the models parameters
that were fit in the previous step. Each combination of parameters is
called a contrast. Below are the different parameter names that where 
estimated across the data set.

```{r}
(param_names <- getCoefNames(mouse, i = "proteins_msqrob", "msqrob_model"))
```

To aid defining contrasts, we will visualise the experimental design
using the `ExploreModelMatrix` package. Since we are not interested in
technical effects, we will only focus on the variables of interest,
here `stimulation` and `genotype`.

```{r, fig.width=5, fig.height=12}
library("ExploreModelMatrix")
vd <- VisualizeDesign(
    sampleData =  colData(mouse),
    designFormula = ~ 0 + condition,
    textSizeFitted = 4
)
vd$plotlist[[1]]
```

So answering the first question, that is "which proteins are
differentially abundant between WT and KO without stimulation?", boils
down to assessing the difference between `conditionWT_NS_0h` and
`conditionKO_NS_0h`, hence the contrast starts with `conditionWT_NS_0h
- conditionKO_NS_0h`. Note that because we used ridge regression for
modelling, we need to prefix the parameter names with `ridge`. We can
further specify the contrast by setting that the difference equals to
zero. This means that our null hypothesis is that there is no
difference between the two groups. We apply the same approach for the
other research questions, and store all the contrasts in a vector.

```{r}
contrasts <- c(
    "ridgeconditionWT_NS_0h - ridgeconditionKO_NS_0h = 0", ## research question 1
    "ridgeconditionWT_LPS_1h - ridgeconditionKO_LPS_1h = 0", ## research question 2
    "ridgeconditionWT_TNF_1h - ridgeconditionKO_TNF_1h = 0", ## research question 3
    "ridgeconditionWT_LPS_6h - ridgeconditionKO_LPS_6h = 0", ## research question 4
    "ridgeconditionWT_TNF_6h - ridgeconditionKO_TNF_6h = 0" ## research question 5
)
```

We next use `makeContrast()` to build a contrast matrix from our 
contrast equations. Each column in the matrix contains one of the
contrast.

```{r}
L <- makeContrast(
    contrasts,
    parameterNames = param_names
)
```

### Hypothesis testing

We can now test our null hypotheses using `hypothesisTest()` which
takes the `QFeatures` object with the fitted model and the contrast
matrix we just built. Again, the results are stored in the set
containing the model, here `proteins_msqrob`

```{r}
mouse <- hypothesisTest(
    mouse, i = "proteins_msqrob", L, modelColumn = "msqrob_model"
)
```

Let us retrieve the result table for the first contrast from the 
`rowData`. Note that the model column is named after the column name 
of the contrast matrix `L`.

```{r}
c1 <- colnames(L)[[1]]
inference <- rowData(mouse[["proteins_msqrob"]])[[c1]]
inference$Protein <- rownames(inference)
inference$Gene <- rowData(mouse[["proteins_msqrob"]])[["Gene.names"]]
```

### Exploring the result

The table contains the hypothesis testing results for every protein.
Notice that some rows contain missing values. This is because data
modelling resulted in a `fitError` for some proteins. We refer to
[another
vignette](https://github.com/statOmics/Msqrob2TMTPaper/blob/master/vignettes/spikein1.qmd)
that describes how to deal with `fitErrors`. We can use the table
above directly to build a volcano plot using `ggplot2` functionality.

```{r}
ggplot(inference) +
    aes(x = logFC, y = -log10(adjPval)) +
    geom_hline(yintercept = -log10(0.05)) +
    geom_text_repel(data = filter(inference, adjPval < 0.05),
                    aes(label = Protein)) +
    geom_point() +
    ggtitle("Statistical inference on differences between LF and HF (short duration)",
            paste("Hypothesis test:", gsub("ridgecondition", "", colnames(L)), "= 0"))
```

TODO write section upon discussion

```{r}
subsetByColData(mouse, mouse$stimulation == "NS") |> 
    detailPlot("P41216", i = "ions_norm", colourVar = "condition") ## Acsl1
```

```{r}
plotOverdispersion(mouse, "proteins_msqrob", ".n", "msqrob_model")
```

# Protein level analysis

TODO needed? 

# Conclusion 

TODO write section 

# Citation 

TODO

# License

This vignette is distributed under a
[Artistic-2.0](https://opensource.org/license/artistic-2-0) license.

# Session info

```{r, echo=FALSE}
sessionInfo()
```


