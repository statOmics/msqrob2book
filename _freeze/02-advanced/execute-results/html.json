{
  "hash": "b0d11e6b41312baebbeadce34d003202",
  "result": {
    "engine": "knitr",
    "markdown": "# Advanced statistical analysis with msqrob2 {#sec-advanced}\n\n\n::: {.cell}\n\n:::\n\n\nThis chapter builds upon the chapter with the [basics](#sec-basics) of differential proteomics data\nanalysis and provides more advanced concepts using `msqrob2`. To\nillustrate these advanced concepts, we will use the spike-in study\npublished by @Huang2020-lu. We chose this data set because:\n\n1. Spike-in data contain ground truth information about which proteins \n   are differentially abundant, enabling us to show the impact of \n   different analysis strategies.\n2. It has been acquired with a TMT-labelling strategy that require a\n   complex experimental design. This provides an excellent example\n   to explain different sources of variability in an MS experiment\n   and demonstrate the flexibility of `msqrob2` to model these sources of\n   variability.\n\n## Background \n\nLabelling strategies in mass spectrometry (MS)-based proteomics \nenhance sample throughput by enabling the acquisition of multiple\nsamples within a single run. The labelling strategy that allows the \nhighest multiplexing is the tandem mass tag (TMT) labelling and will\nbe the focus of the current tutorial.\n\n### TMT workflow{#sec-tmt_workflow}\n\nTMT-based workflow highly overlap with  [label-free\nworkflows](#sec-lfq_workflow). However, TMT-based workflows have an\nadditional sample preparation step, where the digested peptides from\neach sample are labelled with a TMT reagent and samples with different\nTMT reagents are pooled in a single TMT mixture^[Depending on the\nreagents used, 6, 10, 11 up to 18 samples can be pooled in one\nmixture]. The signal processing is also slightly affected since the\nquantification no longer occurs in the MS1 space but at the MS2 level.\nIt is important to understand that TMT reagent are isobaric, meaning\nthat the same peptide with different TMT labels will have the same\nmass for the intact ion, as recorded during MS1. However, the TMT\nfragments that are released upon fragmentation during MS2, also called\nTMT reporter ions, have label-specific masses. The TMT fragments have\nan expected mass and are distributed in a low-mass range of the MS2\nspace. The intensity of each TMT fragment is directly proportional to\nthe peptide quantity in the original sample before pooling. The TMT\nfragment intensities measured during MS2 are used as quantitative\ndata. The higher mass range contains the peptide fragments that\ncompose the peptide fingerprint, similarly to LFQ. This data range is\ntherefore used for peptide identification. Interestingly, the peptide\nfingerprint originates from the same peptide across multiple samples.\nThis leads to a signal boost for low abundant peptides and hence\nshould improve data sensitivity and consistency.\n\n\n::: {.cell}\n::: {.cell-output-display}\n![Overview of an TMT-based proteomics workflow.](figs/tmt_workflow.png){width=60%}\n:::\n:::\n\n\n### Challenges \n\nThe analysis of TMT-based proteomics data shares the same challenges\nas the [data analysis challenges for LFQ](#sec-lfq_challenges). \nHowever, TMT workflows impose additional challenges:\n\n- Contemporary experiments often involve increasingly complex designs, \n  where the number of samples exceeds the capacity of a single TMT\n  mixture, resulting in a complex correlation structure that must be\n  addressed for accurate statistical inference. We will describe in \n  the modelling section the different sources of variation.\n- We also recommend modelling TMT data at the lowest level, that is at\n  the peptide ion level, for optimal performance \n  [@Vandenbulcke2025-sj]. These ion-level models are more complex and\n  include additional sources of variation instead of relying on the \n  summarised protein values. We have shown for LFQ data that a\n  two-step approach where data are first summarised (using a\n  [model-based method](#sec-summarisation)) and then modelled with\n  `msqrob2` leads to similar results, and hence provides more accessible models\n  for non-specialised data analysts [@Sticker2020-rl].\n\n### Experimental context\n\nThe data set used in this chapter is a spike-in experiment\n(PXD0015258) published by @Huang2020-lu. It consists of controlled\nmixtures with known ground truth. UPS1 peptides at concentrations of\n500, 333, 250, and 62.5 fmol were spiked into 50 g of SILAC HeLa\npeptides, each in duplicate. These concentrations form a dilution\nseries of 1, 0.667, 0.5, and 0.125 relative to the highest UPS1\npeptide amount (500 fmol). A reference sample was created by combining\nthe diluted UPS1 peptide samples with 50g of SILAC HeLa peptides. All\ndilutions and the reference sample were prepared in duplicate,\nresulting in a total of ten samples. These samples were then treated\nwith TMT10-plex reagents and combined before LC-MS/MS analysis. This\nprotocol was repeated five times, each with three technical\nreplicates, totaling 15 MS runs.\n\nWe will start from the PSM data generated by Skyline and infer\nprotein-level differences between samples. To achieve this goal, we\nwill apply an msqrob2TMT workflow, a data processing and modelling\nworkflow dedicated to the analysis of TMT-based proteomics datasets.\nWe will demonstrate how the workflow can highlight the spiked-in\nproteins. Before delving into the analysis, let us prepare our\ncomputational environment.\n\n## Load packages\n\nWe load the `msqrob2` package, along with additional packages for\ndata manipulation and visualisation.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(\"msqrob2\")\nlibrary(\"dplyr\")\nlibrary(\"ggplot2\")\nlibrary(\"patchwork\")\n```\n:::\n\n\nWe also configure the [parallelisation](#sec-parallel) framework.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(\"BiocParallel\")\nregister(SerialParam())\n```\n:::\n\n\n## Data\n\n### File caching{#sec-caching}\n\nThe data have been deposited by the authors in the `MSV000084264`\nMASSiVE repository, but we will retrieve the time stamped data from\nour [Zenodo repository](https://zenodo.org/records/14767905). We need\n2 files: the Skyline identification and quantification table generated\nby the authors and the sample annotation files.\n\nTo facilitate management of the files, we download the required files\nusing the `BiocFileCache` package. The package will set up a local\ndatabase in a cache directory^[You will be prompted to create a new\nfolder the first time you use the package.]. `BiocFileCache()` creates\na connection to that database and `bfcrpath()` will query the database\nfor the required URL. If that URL is not present in the database, the\nfunction will automatically download the URL target file and store it\nin the cache directory. If the URL is already present in the database,\nthe function will retrieve the associated file from the local cache\ndirectory. This procedure ensures that the files are downloaded only\nonce while providing a direct link to its source link. When these\nlinks point to permanent archives (like Zenodo) or large public\ndatabases (like PRIDE or MASSiVE), this approach promotes reproducible\nanalyses.\n\nThe chunk below will take some time to complete the first time you run\nit as it needs to download the (large) file locally, but will fetch\nthe local copy the following times.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(\"BiocFileCache\")\nbfc <- BiocFileCache()\npsmFile <- bfcrpath(bfc, \"https://zenodo.org/records/14767905/files/spikein1_psms.txt?download=1\")\nannotFile <- bfcrpath(bfc, \"https://zenodo.org/records/14767905/files/spikein1_annotations.csv?download=1\")\n```\n:::\n\n\nNow the files are downloaded, we can load the two tables. \n\n### PSM table{#sec-psm_table}\n\nAn MS experiment generates spectra. Each MS2 spectrum is used to infer\nthe peptide identity using a search engine. When an observed spectrum\nis matched to a theoretical peptide spectrum, we have a\npeptide-to-spectrum match (PSM). The identification software compiles\nall the PSMs inside a table. Hence, the PSM data is the lowest\npossible level to perform data modelling.\n\nEach row in the PSM data table contains information for one PSM (the\ntable below shows the first 6 rows). The columns contains various\ninformation about the PSM, such as the peptide sequence and charge,\nthe quantified value, the inferred protein group, the measured and\npredicted retention time and precursor mass, the score of the match,\n... In the case of Skyline TMT data, the quantification values are provides in\nmultiple columns (start with `\"Abundance.\"`), one for each TMT label.\nRegardless of TMT or LFQ experiments, the PSM table stacks the\nquantitative values from samples in different runs below each other.\nWe must therefore split the table by run to ensure that every\nquantitative column contains data from a single sample. This is\nperformed during the conversion to a `QFeatures` object.\n\n\n::: {.cell}\n\n```{.r .cell-code}\npsms <- read.delim(psmFile)\nqcols <- grep(\"Abundance\", colnames(psms), value = TRUE)\n```\n:::\n\n\n::: {.cell}\n::: {.cell-output-display}\n\n\n|Checked |Confidence |Identifying.Node |PSM.Ambiguity |Annotated.Sequence                     |Modifications                                                   |Marked.as | X..Protein.Groups| X..Proteins|Master.Protein.Accessions |Master.Protein.Descriptions                                                         |Protein.Accessions |Protein.Descriptions                                                                | X..Missed.Cleavages| Charge| DeltaScore| DeltaCn| Rank| Search.Engine.Rank|  m.z..Da.| MH...Da.| Theo..MH...Da.| DeltaM..ppm.| Deltam.z..Da.|Activation.Type |MS.Order | Isolation.Interference....| Average.Reporter.S.N| Ion.Inject.Time..ms.| RT..min.| First.Scan|Spectrum.File                                |File.ID | Abundance..126| Abundance..127N| Abundance..127C| Abundance..128N| Abundance..128C| Abundance..129N| Abundance..129C| Abundance..130N| Abundance..130C| Abundance..131|Quan.Info | Ions.Score| Identity.Strict| Identity.Relaxed| Expectation.Value| Percolator.q.Value| Percolator.PEP|\n|:-------|:----------|:----------------|:-------------|:--------------------------------------|:---------------------------------------------------------------|:---------|-----------------:|-----------:|:-------------------------|:-----------------------------------------------------------------------------------|:------------------|:-----------------------------------------------------------------------------------|-------------------:|------:|----------:|-------:|----:|------------------:|---------:|--------:|--------------:|------------:|-------------:|:---------------|:--------|--------------------------:|--------------------:|--------------------:|--------:|----------:|:--------------------------------------------|:-------|--------------:|---------------:|---------------:|---------------:|---------------:|---------------:|---------------:|---------------:|---------------:|--------------:|:---------|----------:|---------------:|----------------:|-----------------:|------------------:|--------------:|\n|False   |High       |Mascot (O4)      |Unambiguous   |[K].gFQQILAGEYDHLPEQAFYMVGPIEEAVAk.[A] |N-Term(TMT6plex); K30(TMT6plex)                                 |          |                 1|           1|P06576                    |ATP synthase subunit beta, mitochondrial OS=Homo sapiens GN=ATP5B PE=1 SV=3         |P06576             |ATP synthase subunit beta, mitochondrial OS=Homo sapiens GN=ATP5B PE=1 SV=3         |                   0|      3|     1.0000|       0|    1|                  1| 1270.3249| 3808.960|       3808.966|        -1.51|      -0.00192|CID             |MS2      |                  47.955590|                  8.7|               50.000| 212.2487|     112815|161117_SILAC_HeLa_UPS1_TMT10_Mixture1_03.raw |F1      |       2548.326|        3231.929|        2760.839|        4111.639|        3127.254|        1874.163|        2831.423|        2298.401|        3798.876|       3739.067|NA        |         90|              28|               21|         0.0000000|                  0|      0.0000140|\n|False   |High       |Mascot (K2)      |Unambiguous   |[R].qYPWGVAEVENGEHcDFTILr.[N]          |N-Term(TMT6plex); C15(Carbamidomethyl); R21(Label:13C(6)15N(4)) |          |                 1|           1|Q16181                    |Septin-7 OS=Homo sapiens GN=SEPT7 PE=1 SV=2                                         |Q16181             |Septin-7 OS=Homo sapiens GN=SEPT7 PE=1 SV=2                                         |                   0|      3|     1.0000|       0|    1|                  1|  920.4493| 2759.333|       2759.332|         0.31|       0.00028|CID             |MS2      |                   9.377507|                  8.1|                3.242| 164.7507|      87392|161117_SILAC_HeLa_UPS1_TMT10_Mixture3_03.raw |F5      |      22861.765|       25817.946|       23349.498|       29449.609|       25995.929|       22955.769|       30578.971|       30660.488|       38728.853|      25047.280|NA        |         76|              24|               17|         0.0000001|                  0|      0.0000003|\n|False   |High       |Mascot (K2)      |Unambiguous   |[R].dkPSVEPVEEYDYEDLk.[E]              |N-Term(TMT6plex); K2(Label); K17(Label)                         |          |                 1|           1|Q9Y450                    |HBS1-like protein OS=Homo sapiens GN=HBS1L PE=1 SV=1                                |Q9Y450             |HBS1-like protein OS=Homo sapiens GN=HBS1L PE=1 SV=1                                |                   1|      3|     0.9730|       0|    1|                  1|  920.1605| 2758.467|       2758.461|         2.08|       0.00192|CID             |MS2      |                  38.317050|                 17.8|               13.596| 143.4534|      74786|161117_SILAC_HeLa_UPS1_TMT10_Mixture3_03.raw |F5      |      25504.083|       27740.450|       25144.974|       25754.579|       29923.176|       34097.637|       31650.255|       27632.692|       23886.881|      35331.092|NA        |         74|              30|               23|         0.0000004|                  0|      0.0000010|\n|False   |High       |Mascot (F2)      |Selected      |[R].hEHQVMLmr.[Q]                      |N-Term(TMT6plex); M8(Oxidation); R9(Label:13C(6)15N(4))         |          |                 1|           1|Q15233                    |Non-POU domain-containing octamer-binding protein OS=Homo sapiens GN=NONO PE=1 SV=4 |Q15233             |Non-POU domain-containing octamer-binding protein OS=Homo sapiens GN=NONO PE=1 SV=4 |                   0|      4|     0.5250|       0|    1|                  1|  359.6898| 1435.737|       1435.738|        -0.04|      -0.00002|CID             |MS2      |                  21.390040|                 36.5|               50.000|  21.6426|       6458|161117_SILAC_HeLa_UPS1_TMT10_Mixture4_02.raw |F10     |      13493.228|       14674.490|       11187.900|       12831.495|       13839.426|       12441.353|       13450.885|       14777.844|       13039.995|      12057.121|NA        |         40|              25|               18|         0.0003351|                  0|      0.0001175|\n|False   |High       |Mascot (K2)      |Unambiguous   |[R].dNLTLWTADNAGEEGGEAPQEPQS.[-]       |N-Term(TMT6plex)                                                |          |                 1|           1|P31947                    |14-3-3 protein sigma OS=Homo sapiens GN=SFN PE=1 SV=1                               |P31947             |14-3-3 protein sigma OS=Homo sapiens GN=SFN PE=1 SV=1                               |                   0|      3|     1.0000|       0|    1|                  1|  920.0943| 2758.268|       2758.264|         1.53|       0.00141|CID             |MS2      |                   0.000000|                 16.7|                6.723| 174.1863|      92950|161117_SILAC_HeLa_UPS1_TMT10_Mixture3_03.raw |F5      |      64582.786|       50576.417|       47126.037|       56285.129|       46257.310|       52634.885|       49716.850|       60660.574|       55830.488|      40280.577|NA        |         38|              21|               14|         0.0002153|                  0|      0.0000138|\n|False   |High       |Mascot (K2)      |Unambiguous   |[R].aLVAIGTHDLDTLSGPFTYTAk.[R]         |N-Term(TMT6plex); K22(Label)                                    |          |                 1|           1|Q9NSD9                    |Phenylalanine--tRNA ligase beta subunit OS=Homo sapiens GN=FARSB PE=1 SV=3          |Q9NSD9             |Phenylalanine--tRNA ligase beta subunit OS=Homo sapiens GN=FARSB PE=1 SV=3          |                   0|      3|     0.9783|       0|    1|                  1|  919.8502| 2757.536|       2757.532|         1.48|       0.00136|CID             |MS2      |                  30.619960|                 26.7|                8.958| 176.4863|      94294|161117_SILAC_HeLa_UPS1_TMT10_Mixture3_03.raw |F5      |      35404.709|       31905.852|       30993.941|       36854.351|       37506.001|       25703.444|       38626.598|       35447.942|       33788.409|      32031.516|NA        |         46|              29|               22|         0.0002060|                  0|      0.0000720|\n\n\n:::\n:::\n\n\nThere is a peculiarity with the dataset: the spectra have been\nidentified with 2 nodes. In one node, the authors searched the\nSwissProt database for proteins with static modifications related to\nthe metabolic labelling, in the other node they searched the Sigma_UPS\nprotein database without these static modifications. However, some\nspectra were identified by both nodes leading to duplicate PSMs. We\nhere remove these duplicated PSMs that are identification artefacts.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nduplicatesQuants <- duplicated(psms[, qcols]) | duplicated(psms[, qcols], fromLast = TRUE)\npsms <- psms[!duplicatesQuants, ]\n```\n:::\n\n\nWe will also subset the data set to reduce computational costs. If you\nwant to run the analysis on the full data set, you can skip this code\nchunk. The subsetting will keep all UPS proteins, known to be\ndifferentially abundant by experimental design, and we will keep 500\nbackground proteins known to be unchanged across condition.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nallProteins <- unique(psms$Protein.Accessions)\nupsProteins <- grep(\"ups\", allProteins, value = TRUE)\nhelaProteins <- grep(\"ups\", allProteins, value = TRUE, invert = TRUE)\nset.seed(1234)\nkeepProteins <- c(upsProteins, sample(helaProteins, 500))\npsms <- psms[psms$Protein.Accessions %in% keepProteins, ]\n```\n:::\n\n\n### Sample annotation table\n\nThe purpose and structure of the sample annotation table is identical\nacross proteomics experiments (see introduction to the [sample\nannotation table](#sec-annotation_table)). The annotation table used\nin this tutorial has been generated by the authors.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncoldata <- read.csv(annotFile)\n```\n:::\n\n\nWe perform a little cleanup:\n\n1. We keep only the sample annotations that are meaningful to the \n   experiment and that are not redundant with other annotations.\n2. We extract the run identifier from the MS file name (which we store\n   as the `File.Name` annotation).\n3. The TMT used for labelling each sample is stored in the `Channel` \n   column. We however prefer to use the less esoteric term `Label`\n   for more clarity with the main text when we'll discuss labelling\n   effects.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n## 1.\ncoldata <- coldata[, c(\"Run\", \"Channel\", \"Condition\", \"Mixture\", \"TechRepMixture\")]\n## 2.\ncoldata$File.Name <- coldata$Run\ncoldata$Run <- sub(\"^.*(Mix.*).raw\", \"\\\\1\", coldata$Run)\n## 3.\ncolnames(coldata)[2] <- \"Label\"\n```\n:::\n\n\n::: {.cell}\n::: {.cell-output-display}\n\n\n|Run         |Label |Condition |Mixture  | TechRepMixture|File.Name                                    |\n|:-----------|:-----|:---------|:--------|--------------:|:--------------------------------------------|\n|Mixture1_01 |126   |Norm      |Mixture1 |              1|161117_SILAC_HeLa_UPS1_TMT10_Mixture1_01.raw |\n|Mixture1_01 |127N  |0.667     |Mixture1 |              1|161117_SILAC_HeLa_UPS1_TMT10_Mixture1_01.raw |\n|Mixture1_01 |127C  |0.125     |Mixture1 |              1|161117_SILAC_HeLa_UPS1_TMT10_Mixture1_01.raw |\n|Mixture1_01 |128N  |0.5       |Mixture1 |              1|161117_SILAC_HeLa_UPS1_TMT10_Mixture1_01.raw |\n|Mixture1_01 |128C  |1         |Mixture1 |              1|161117_SILAC_HeLa_UPS1_TMT10_Mixture1_01.raw |\n|Mixture1_01 |129N  |0.125     |Mixture1 |              1|161117_SILAC_HeLa_UPS1_TMT10_Mixture1_01.raw |\n\n\n:::\n:::\n\n\n### Convert to QFeatures{#sec_advanced_readqf}\n\nWe use `readQFeatures()` to create a [`QFeatures`\nobject](#sec-qfeatures). Since we start from the PSM-level data, the\napproach is somewhat more elaborate^[You can find an illustrated\nstep-by-step guide in the [QFeatures\nvignette](https://rformassspectrometry.github.io/QFeatures/articles/read_QFeatures.html)].\nFirst, recall that every quantitative column in the PSM table contains\ninformation for multiple runs. Therefore, the function split the table\nbased on the run identifier, given by the `runCol` argument (for\nSkyline, that identifier is contained in `Spectrum.File`). So, the\n`QFeatures` object after import will contain as many sets as there are\nruns. Next, the function links the annotation table with the PSM data.\nTo achieve this, the annotation table must contain a `runCol` column\nthat provides the run identifier in which each sample has been\nacquired, and this information will be used to match the identifiers\nin the `Spectrum.File` column of the PSM table. The annotation table \nmust also contain a `quantCols` column that tells the function which\ncolumn in the PSM table contains the quantitative information for a \ngiven sample. In this case, the `quantCols` depend on \n\n\n::: {.cell}\n\n```{.r .cell-code}\ncoldata$runCol <- coldata$File.Name\ncoldata$quantCols <- paste0(\"Abundance..\", coldata$Label)\n(spikein <- readQFeatures(\n  psms, colData = coldata,\n  runCol = \"Spectrum.File\",\n  quantCols = qcols\n))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nAn instance of class QFeatures (type: bulk) with 15 sets:\n\n [1] 161117_SILAC_HeLa_UPS1_TMT10_Mixture1_01.raw: SummarizedExperiment with 1905 rows and 10 columns \n [2] 161117_SILAC_HeLa_UPS1_TMT10_Mixture1_02.raw: SummarizedExperiment with 1902 rows and 10 columns \n [3] 161117_SILAC_HeLa_UPS1_TMT10_Mixture1_03.raw: SummarizedExperiment with 1952 rows and 10 columns \n ...\n [13] 161117_SILAC_HeLa_UPS1_TMT10_Mixture5_01.raw: SummarizedExperiment with 1919 rows and 10 columns \n [14] 161117_SILAC_HeLa_UPS1_TMT10_Mixture5_02.raw: SummarizedExperiment with 1909 rows and 10 columns \n [15] 161117_SILAC_HeLa_UPS1_TMT10_Mixture5_03.raw: SummarizedExperiment with 1844 rows and 10 columns \n```\n\n\n:::\n:::\n\n\nWe now have a `QFeatures` object with 15 sets, each containing data\nassociated with an MS run. The name of each set is defined by the name\nof the corresponding file name of the run, which is unnecessarily\nlong. We simplify the set names, although this step is optional and\nonly meant to improve the clarity of the output.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n## This is optional\nnames(spikein) <- sub(\"^.*(Mix.*).raw\", \"\\\\1\", names(spikein))\n(inputNames <- names(spikein))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1] \"Mixture1_01\" \"Mixture1_02\" \"Mixture1_03\" \"Mixture2_01\" \"Mixture2_02\"\n [6] \"Mixture2_03\" \"Mixture3_01\" \"Mixture3_02\" \"Mixture3_03\" \"Mixture4_01\"\n[11] \"Mixture4_02\" \"Mixture4_03\" \"Mixture5_01\" \"Mixture5_02\" \"Mixture5_03\"\n```\n\n\n:::\n:::\n\n\n## Data preprocessing\n\nSimilar to the [basic concepts chapter](#sec-basic_preprocess), we \nwill use the `QFeatures`' data preprocessing functionality. The \ndata preprocessing workflow for TMT data is similar to the workflow\nfor LFQ data, but there are subtle differences associated with the\nfact that we start from PSM-level data, namely the PSM filtering is\nmode complex and the data preprocessing will be applied for each run \nseparately to remove part of the run effect. \n\n### Encoding missing values\n\nAny zero value needs to be [encoded by a missing\nvalue](#sec-encode_missing).\n\n\n::: {.cell}\n\n```{.r .cell-code}\nspikein <- zeroIsNA(spikein, inputNames)\n```\n:::\n\n\n### Log2 transformation\n\nSimilar to any MS-based proteomics data, TMT data are heteroskedastic,\nwith a strong mean-variance relationship. This is illustrated by the\nintensities and log2-intensities for one of the peptide ions, the\ntriply charged DLLHVLAFSK, in function of the UPS spike-in dilution\nfactor. \n\n\n::: {.cell}\n::: {.cell-output-display}\n![ ](02-advanced_files/figure-html/advanced_log_plot-1.png){width=672}\n:::\n:::\n\n\nLog2-transformation solves the heteroskedasticity issue, but also\nprovides a scale that directly relates to biological interpretation\n(see the [basic concepts chapter](#sec-log2)). We perform \nlog2-transformation with `logTransform()` from the `QFeatures` package.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlogNames  <- paste0(inputNames, \"_log\")\nspikein <- logTransform(\n    spikein, inputNames, name = logNames, base = 2\n)\n```\n:::\n\n\n### Sample filtering\n\nWe first remove the reference samples. These samples were used by the\nMSstatsTMT authors to obtain normalisation factors [@Huang2020-lu].\nHowever, this approach ignores the uncertainty associated with the\nmeasurement with these reference samples, potentially inflating the\nnoise in the samples of interest. Hence, `msqrob2` workflows do not\nuse reference normalisation. In practice, we found no impact on model\nperformance [@Vandenbulcke2025-sj], hence we favor a more parsimonious\napproach. The information is available from the `colData`, under the\n`Condition` column. We remove any sample that is marked as `Norm` \nusing `subsetByColData()`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nspikein <- subsetByColData(spikein, spikein$Condition != \"Norm\")\n```\n:::\n\n\n### PSM filtering\n\nFiltering removes low-quality and unreliable PSMs that would otherwise\nintroduce noise and artefacts in the data. Conceptually, PSM filtering\nis identical to [peptide filtering](#sec-filter), but we will here\napply filtering criteria for which some are not readily available in\nthe data. Therefore, we will add custom filtering variable to the\n`rowData` that will then be used with `filterFeatures()`. This\nprovides an ideal use case to demonstrate the customisation of a\nfiltering workflow.\n\n#### Remove ambiguous identifications\n\nThe background proteins originate from HeLa cells, which also contain\nUPS proteins. The background UPS proteins and the spiked-in UPS\nproteins differ in metabolic labelling, so we should be able to\ndistinguish them. We used the PSM-level data searched with mascot, as\nprovided by the MSstatsTMT authors who used two mascot identification\nnodes. In one node they searched the SwissProt database for proteins\nwith static modifications related to the metabolic labelling, in the\nother node they searched the Sigma_UPS protein database without these\nstatic modifications. Ideally, this should separate the spiked-in UPS\nproteins and the UPS proteins from the HeLa cells, however, this is\nnot always the case. The SwissProt search is expected to return\npeptide-spectrum matches (PSMs) for all proteins, including non-UPS\nHeLa, UPS HeLa, and spike-in UPS proteins. Conversely, the Sigma_UPS\nsearch is expected to return PSMs exclusively for spike-in UPS\nproteins. However, a PSM that matches a UPS protein in the SwissProt\nsearch but is not identified as such in the Sigma_UPS search could\neither correctly originate from a HeLa protein or represent a\nspiked-in UPS protein that was not recognised as such in the Sigma_UPS\nsearch. Additionally, there are ambiguous PSMs that are not matched to\na UPS protein in the HeLa search but are matched to a UPS protein in\nthe SwissProt search. To address this, we exclude these ambiguous\nproteins from the analysis.\n\nTo define the amibiguous PSMs, we retrieve the PSM annotations from\nthe `rowData` and create a new colum indicating whether a PSM belongs\nto a UPS protein or not, based on the protein SwissProt identifiers.\nFor this, we apply a custom filtering worklow:\n\n1. **Collect data**: combine all the `rowData` information in a single\n   table. We will apply the filter on the \n\n\n::: {.cell}\n\n```{.r .cell-code}\nrowdata <- rbindRowData(spikein, logNames)\n```\n:::\n\n\n2. **Compute new variable**: (2a) define whether the PSM's protein \n   group is a UPS protein and then (2b) define an ambiguous PSM as a\n   PSM that is marked as UPS by the SwissProt identifier but not by\n   the Sigma_UPS node (`Marked.as` column), and inversely.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n## 2a.\nrowdata$isUps <- \"no\"\nisUpsProtein <- grepl(\"ups\", rowdata$Protein.Accessions)\nrowdata$isUps[isUpsProtein] <- \"yes\"\n## 2b.\nrowdata$isUps[!isUpsProtein & grepl(\"UPS\", rowdata$Marked.as)] <- \"amb\"\nrowdata$isUps[isUpsProtein & !grepl(\"UPS\", rowdata$Marked.as)] <- \"amb\"\n```\n:::\n\n\n3. **Reinsert in the rowData**: insert the modified table with new \n   information back in the `rowData` of the different sets. This means\n   that the single table with `rowData` information needs to be split\n   by each set. `split()` will produce a named list of tables and each\n   table will be iteratively inserted as `rowData` of the set.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrowData(spikein) <- split(rowdata, rowdata$assay)\n```\n:::\n\n\n4. **Apply the filter**: the filtering is performed by \n   `filterFeatures()` using the new information from the `rowData`. We\n   specify `keep = TRUE` because the input sets (before\n   log-transformation) do not contain the filtering variable, so we\n   tell the function to keep all PSMs for the sets that don't have the\n   variable `isUps`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nspikein <- filterFeatures(spikein, ~ isUps != \"amb\", keep = TRUE)\n```\n:::\n\n\n#### Remove failed protein inference\n\nNext, we remove PSMs that could not be mapped to a protein or that map\nto multiple proteins, i.e. a protein group. For the latter, the\nprotein identifier contains multiple identifiers separated by a `;`).\nThis information is readily available in the `rowData`, so there is no\nneed for a custom filtering.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nspikein <- filterFeatures(\n    spikein, ~ Protein.Accessions != \"\" & ## Remove failed protein inference\n        !grepl(\";\", Protein.Accessions)) ## Remove protein groups\n```\n:::\n\n\n#### Remove inconsistent protein inference\n\nWe also remove peptide ions that map to a different protein depending\non the run. Again, this requires a custom filtering and we apply the\nsame filtering workflow as above.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n## 1. Collect data\nrowdata <- rbindRowData(spikein, logNames)\n## 2. Compute new variable\nrowdata <- data.frame(rowdata) |>\n    group_by(Annotated.Sequence, Charge) |>\n    mutate(nProtsMapped = length(unique(Protein.Accessions)))\n## 3. Reinsert in the rowData\nrowData(spikein) <- split(rowdata, rowdata$assay)\n## 4. Apply the filter\nspikein <- filterFeatures(spikein, ~ nProtsMapped == 1, keep = TRUE)\n```\n:::\n\n\n#### Remove one-run wonders\n\nWe also remove proteins that can only be found in one run as such\nproteins may not be trustworthy. In this case, \n\n\n::: {.cell}\n\n```{.r .cell-code}\n## 1. Collect data\nrowdata <- rbindRowData(spikein, logNames)\n## 2. Compute new variable\nrowdata <- data.frame(rowdata) |>\n    group_by(Protein.Accessions) |>\n    mutate(nRuns = length(unique(assay)))\n## 3. Reinsert in the rowData\nrowData(spikein) <- split(rowdata, rowdata$assay)\n## 4. Apply the filter\nspikein <- filterFeatures(spikein, ~ nRuns > 1, keep = TRUE)\n```\n:::\n\n\n#### Remove duplicated PSMs{#sec-duplicated_psms}\n\nFinally, peptide ions that were identified with multiple PSMs in a run\nare collapsed to the PSM with the highest summed intensity over the\nTMT labels, a strategy that is also used by MSstats.\n\nThis filtering requires a more complex workflow because it mixes\ninformation from the `rowData` (to obtain ion identities) with\nquantitative data (to obtain PSM intensity ranks). We therefore \ncompute the filtering variable for every set iteratively:\n\n1. Get the `rowData` for the current set.\n2. Make a new variable `ionID`.\n3. We calculate the `rowSums` for each ion.\n4. Make a new variable `psmRank` that ranks the PSMs for each ion \n   identifier based on the summed intensity.\n5. We store the new information back in the `rowData`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfor (i in logNames) { ## for each set of interest\n    rowdata <- rowData(spikein[[i]]) ## 1.\n    rowdata$ionID <- paste0(rowdata$Annotated.Sequence, rowdata$Charge) ## 2.\n    rowdata$rowSums <- rowSums(assay(spikein[[i]]), na.rm = TRUE) ## 3.\n    rowdata <- data.frame(rowdata) |>\n        group_by(ionID) |>\n        mutate(psmRank = rank(-rowSums)) ## 4.\n    rowData(spikein[[i]]) <- DataFrame(rowdata) ## 5.\n}\n```\n:::\n\n\nFor each ion that maps to multiple PSMs, we keep the PSM with the\nhighest summed intensity, that is that ranks first. \n\n\n::: {.cell}\n\n```{.r .cell-code}\nspikein <- filterFeatures(spikein, ~ psmRank == 1, keep = TRUE)\n```\n:::\n\n\n#### Remove highly missing PSMs\n\nWe then remove PSMs with five or more missing values out of the ten\nTMT labels (>= 50%). This is an arbitrary value that may need to be\nadjusted depending on the experiment and the data set.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nspikein <- filterNA(spikein, logNames, pNA = 0.5)\n```\n:::\n\n\n#### Filtering wrap-up\n\nWe have demonstrated the different procedures to perform feature\nfiltering. Here is a summary (from simple to complex):\n\n1. If you want to filter on missing values, use `filterNA()`.\n2. If you want to filter based on a `rowData` column, use \n   `filterFeatures()`.\n3. If you want to filter based on information that needs to be built \n   from `rowData` information, use the following workflow: i. collect\n   the `rowData` in a table; ii. compute the new variable; iii.\n   reinsert the updated table in the `rowData`; iv. apply the filter\n   with `filterFeatures()`.\n4. If you want to filter based on `rowData` and quantitative \n   information, iterate the following workflow over each set: \n   i. Get the `rowData` for the current set; ii. Compute the filtering\n   variable based on `rowData` and/or quantitative information; iii.\n   store the new information back in the `rowData`. Then, the \n   filtering can be performed by `filterFeatures()`.\n\nWhen using `filterFeatures()`, specify `keep = TRUE` to select all\nfeatures for which a custom variable is not available or has not been\ncomputed. By default, the function will remove all the feature of a\nset for which the information is not available.\n\nThese standard and custom filtering procedures have been demonstrated\non PSM-level data, but the same procedures can be performed at any\ndata level, e.g. also at peptide or protein level.\n\n### Normalisation\n\nBefore performing normalisation, we explore the systematic shifts\nacross the samples (using the pipeline described in the [previous\nchapter](#sec-norm)). To facilitate interpretation, we facet the data\nby TMT mixture.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nspikein[, , logNames] |>\n    longForm(colvars = c(\"Mixture\", \"TechRepMixture\")) |>\n    data.frame() |>\n    ggplot() +\n    aes(x = value, colour = as.factor(TechRepMixture), group = colname) +\n    geom_density() +\n    labs(title = \"Intensity distribution for each observational unit\",\n         subtitle = \"Before normalisation\",\n         colour = \"Technical replicate\") +\n    facet_grid(Mixture ~ .) +\n    theme(legend.position = \"bottom\")\n```\n\n::: {.cell-output-display}\n![ ](02-advanced_files/figure-html/advanced_before_norm-1.png){width=480}\n:::\n:::\n\n\nSimilarly to the previous chapter, we again observe misalignments of\nthe intensity distributions across samples. We see the intensity\ndistributions cluster by technical replicate. Since each replicate\ncontains all experimental conditions, we know that these difference\nstem from technical variability and not biological variability. We\nnormalise the data by median centering.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnormNames  <- paste0(inputNames, \"_norm\")\nspikein <- normalize(\n    spikein, logNames, name = normNames,\n    method = \"center.median\"\n)\n```\n:::\n\n\n**TODO** think about using the Median of Ratio normalisation for tmt \ndata. \n\nAnd we confirm that the normalisation resulted in a better alignment\nof the intensity distribution across samples.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nspikein[, , normNames] |>\n    longForm(colvars = c(\"Mixture\", \"TechRepMixture\")) |>\n    data.frame() |>\n    ggplot() +\n    aes(x = value, colour = as.factor(TechRepMixture), group = colname) +\n    geom_density() +\n    labs(title = \"Intensity distribution for each observational unit\",\n         subtitle = \"Before normalisation\",\n         colour = \"Technical replicate\") +\n    facet_grid(Mixture ~ .) +\n    theme(legend.position = \"bottom\")\n```\n\n::: {.cell-output-display}\n![ ](02-advanced_files/figure-html/advanced_after_norm-1.png){width=480}\n:::\n:::\n\n\nUp to now, the data from different runs were kept in separate assays.\nWe can now join the normalised sets into an `ions` set using\n`joinAssays()`. Sets are joined by stacking the columns (samples) in a\nmatrix and rows (features) are matched according to a row identifier,\nhere the `ionID` from the `rowData`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n(spikein <- joinAssays(\n    spikein, normNames, fcol = \"ionID\", name = \"ions\"\n))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nAn instance of class QFeatures (type: bulk) with 46 sets:\n\n [1] Mixture1_01: SummarizedExperiment with 1719 rows and 8 columns \n [2] Mixture1_02: SummarizedExperiment with 1722 rows and 8 columns \n [3] Mixture1_03: SummarizedExperiment with 1776 rows and 8 columns \n ...\n [44] Mixture5_02_norm: SummarizedExperiment with 1646 rows and 8 columns \n [45] Mixture5_03_norm: SummarizedExperiment with 1578 rows and 8 columns \n [46] ions: SummarizedExperiment with 4066 rows and 120 columns \n```\n\n\n:::\n:::\n\n\nWe have a new set contain 15 runs $\\times$ 8 labelled sample = 120\ndata columns. Note that the 15 sets have 4066\nions in common, leading to a joined set with `r\nnrows(spikein)[[\"ions\"]]` rows.\n\nIf we want to use protein-level data for modelling, we will need a\nsummarisation step. Note that this last step is optional.\n\n### Summarisation\n\nWhile this chapter will focus on ion-level data modelling, modelling\nof protein-level data is possible upon summarisation. Below, we\nillustrate the challenges of [summarising](#sec-summarisation) TMT\ndata using one of the UPS proteins in Mixture 1 (separating the data\nfor each technical replicate). We also focus on the 0.125x and the 1x\nspike-in conditions. We illustrate the different peptide ions on the x\naxis and plot the log2 normalised intensities across samples on y\naxis. All the points belonging to the same sample are linked through a\ngrey line.\n\n\n::: {.cell}\n::: {.cell-output-display}\n![ ](02-advanced_files/figure-html/advanced_summarise-1.png){width=576}\n:::\n:::\n\n\nWe see that the same challenges observed for [LFQ\ndata](#sec-summarisation) also apply to TMT data. Briefly:\n\n1. Data for a protein can consist of many peptide ions. \n2. Peptide ions have different intensity baselines.\n3. There is strong missingness across runs (compare points between \n   replicates), but the missingness is mitigated within runs (compare\n   points within replicates^[Note that the data points from one\n   peptide ion in one replicate has been extracted from a single MS2\n   spectrum.]).\n4. Subtle intensity shifts for the same peptide across different\n   replicates, called spectrum effects, are caused by small run-to-run\n   fluctuations.\n5. Presence of outliers. For instance, the first peptide ion \n   doesn't show the same change in intensity between conditions\n   compared to majority of the peptides. \n\n**TODO**: use robust summary instead of median polish for consistency\nwith previous vignette? I known median polish is faster, but still?\n\nHere, we summarise the ion-level data into protein intensities\nthrough the median polish approach, which alternately removes the\npeptide-ions and the sample medians from the data until the summaries\nstabilise. Removing the peptide-ion medians will solve issue 2. as it\nremoves the ion-specific effects. Using the median instead of\nthe mean will solve issue 5. Note that we perform summarisation for\neach run separately, hence the ion effect will be different for\neach run, effectively allowing for a spectrum effect and solving\nissue 4.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsummNames <- paste0(inputNames, \"_proteins\")\n(spikein <- aggregateFeatures(\n    spikein, i = normNames,  name = summNames,\n    fcol = \"Protein.Accessions\", fun = MsCoreUtils::medianPolish,\n    na.rm = TRUE\n))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nAn instance of class QFeatures (type: bulk) with 61 sets:\n\n [1] Mixture1_01: SummarizedExperiment with 1719 rows and 8 columns \n [2] Mixture1_02: SummarizedExperiment with 1722 rows and 8 columns \n [3] Mixture1_03: SummarizedExperiment with 1776 rows and 8 columns \n ...\n [59] Mixture5_01_proteins: SummarizedExperiment with 307 rows and 8 columns \n [60] Mixture5_02_proteins: SummarizedExperiment with 296 rows and 8 columns \n [61] Mixture5_03_proteins: SummarizedExperiment with 299 rows and 8 columns \n```\n\n\n:::\n:::\n\n\nWe can now join the different protein sets into a single set. We omit\nthe `fcol` argument, meaning that the set rows will be matched based\non the row names (generated by `aggregateFeatures()`).\n\n\n::: {.cell}\n\n```{.r .cell-code}\nspikein <- joinAssays( \n    spikein, summNames, \"proteins\"\n)\n```\n:::\n\n\n## Data exploration\n\nWe perform data exploration using MDS, using the same pipeline as\nin [the previous chapter](#sec_data_exploration).\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(\"scater\")\nse <- getWithColData(spikein, \"ions\")\nse <- runMDS(as(se, \"SingleCellExperiment\"), exprs_values = 1)\nplotMDS(se, colour_by = \"Condition\") +\n  plotMDS(se, colour_by = \"Run\") + \n  plotMDS(se, colour_by = \"Mixture\")\n```\n\n::: {.cell-output-display}\n![ ](02-advanced_files/figure-html/advanced_mds-1.png){width=768}\n:::\n:::\n\n\nThere is a strong run-to-run effect, which is partly explained by a\nmixture effect as the runs from the same mixture tend to be closer\nthan runs from different mixtures. The condition effect is much more\nsubtle to find, probably because we know only a few UPS proteins were\nspiked in while the majority of the background proteins are unchanged.\n\nAs discussed above, the median polish summarisation should remove part\nof the run to run effect. We repeat the data exploration, but using\nthe protein-level data.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nse <- getWithColData(spikein, \"proteins\")\nse <- runMDS(as(se, \"SingleCellExperiment\"), exprs_values = 1)\nplotMDS(se, colour_by = \"Condition\") +\n  plotMDS(se, colour_by = \"Run\") + \n  plotMDS(se, colour_by = \"Mixture\")\n```\n\n::: {.cell-output-display}\n![ ](02-advanced_files/figure-html/advanced_mds_proteins-1.png){width=768}\n:::\n:::\n\n\nWhile the run effects are smaller (i.e. points within a run are more\nscattered than on the previous plots) on the protein-level MDS\ncompared to the ion-level MDS (the samples are less clustered per\nrun), we can see that normalisation and summarisation alone are not\nsufficient to correct for these unwanted effects. We will take care of\nthese effects during the data modelling.\n\n## Data modelling{#sec-run_model}\n\nProteomics data contain several sources of variation that need to be\naccounted for by the model. Before delving into these sources of \nvariation, we here show how to run the model that accounts for all\nrelevant sources of variation in the spike-in experiment, which we\nhave shown performs best [@Vandenbulcke2025-sj].\n\n\n::: {.cell}\n\n```{.r .cell-code}\nspikein <- msqrobAggregate(\n    spikein,  i = \"ions\",\n    formula = ~ Condition + ## fixed effect for experimental condition\n        (1 | Label) + ## random effect for label\n        (1 | Mixture) + ## random effect for mixture\n        (1 | Run) + ## random effect for run\n        (1 | Run:Label) + ## random effect for PSMs for the same protein in a label of a run\n        (1 | Run:ionID), ## random effect for ions in the same spectrum of an MS run\n    fcol = \"Protein.Accessions\",\n    modelColumnName = \"msqrob_psms_rrilm\",\n    robust = TRUE, ridge = TRUE\n)\n```\n:::\n\n\nWe will now build the model by progressively adding the different\nsources of variation.\n\n### Effect of treatment of interest{#sec-fixed_effect}\n\nWe model the source of variation induced by the experimental\ntreatment of interest as a **fixed effect**, which we consider\nnon-random, i.e. the treatment effect is assumed to be the same in\nrepeated experiments, but it is unknown and has to be estimated. When\nmodelling a typical label-free experiment at the protein level, the\nmodel boils down to a linear model, again we suppress the index for\nprotein:\n\n$$\ny_i = \\mathbf{x}^T_i \\boldsymbol{\\beta} + \\epsilon_i,\n$$\n\nwith $y_i$ the $\\log_2$-normalised protein intensities in sample $i$ out of $N$ samples;\n$\\mathbf{x}_i$ a vector with the covariate pattern for the sample in\nrun $r$ encoding the intercept, treatment, potential batch effects and\nconfounders; $\\boldsymbol{\\beta}$ the vector of parameters that model\nthe association between the covariates and the outcome; and\n$\\epsilon_i$ the residuals reflecting variation that is not captured\nby the fixed effects. Note that $\\mathbf{x}_i$ allows for a flexible\nparameterisation of the treatment beyond a single covariate, i.e.\nincluding a 1 for the intercept, continuous and categorical variables\nas well as their interactions. For all models considered in this work,\nwe assume the residuals to be independent and identically distributed\n(i.i.d) according to a normal distribution with zero mean and constant\nvariance, i.e. $\\epsilon_{i} \\sim N(0,\\sigma_\\epsilon^2)$, that can\ndiffer from protein to protein.\n\nWe could estimate this model from the data using \n`msqrob()` (described in the [previous chapter](#sec-msqrob)), i.e. the\nmodel translates into the following code:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# spikein <- msqrob(\n#     spikein,  i = \"proteins\",\n#     formula = ~ Condition, ## fixed effect for experimental condition\n#     robust = TRUE, ridge = TRUE\n# )\n```\n:::\n\n\nThis model, however, does not model all sources of variation in the experiment and relying on its results would lead\nto incorrect conclusions. We therefore did not run the modelling command and will\nexpand the model.\n\n### Effect of run{#sec-random_effect}\n\nAs label-free experiments contain only a single sample per run,\nrun-specific effects will be absorbed in the residuals. However, the\ndata analysis of multiplexed experiments involving multiple MS runs\nhas to account for run-specific effects, explicitly. If all treatments\nare present in each run, then the model parameters can be estimated\nusing fixed run effects. Indeed, for these designs run acts as a\nblocking variable as all treatment effects can be estimated within\neach run.\n\nHowever, for more complex designs this is no longer possible and the\nuncertainty in the estimation of the mean model parameters can involve\nboth within and between run variability. For these designs we\ncan resort to mixed models where the run effect is modelled using\n**random effects**, i.e. they are considered as a random sample from\nthe population of all possible runs, which are assumed to be\ni.i.d normally distributed with mean 0 and constant variance,\n$u_{run} \\sim N(0,\\sigma^2_\\text{run})$. The use of random\neffects thus models the correlation in the data, explicitly. Indeed,\nprotein intensities that are measured within the same run will be\nmore similar than protein intensities between runs.\n\nHence, the model is extended to:\n\n$$\ny_{i} =\n\\mathbf{x}^T_{i} \\boldsymbol{\\beta} + u_r^\\text{run} + \\epsilon_{i}\n$$\nwith $y_{i}$ the normalised $\\log_2$ protein intensities measured in sample $i$ that has been acquired in\nrun $r$ out of $R$ runs, and $u_r^\\text{run}$ the effect\nintroduced by run $r$.\n\nWe can also write the model in matrix form:\n\n$$\n\\mathbf{Y} = \\mathbf{X}\\boldsymbol{\\beta} + \\mathbf{Zu}^\\text{run} + \\boldsymbol{\\epsilon}\n$$\nwith\n$$\n\\mathbf{Y}=\\left[\n  \\begin{array}{c} y_{1} \\\\\\vdots\\\\ y_{i} \\\\\\vdots\\\\ y_{N}\\end{array}\n\\right],\n\\mathbf{X}=\\left[\n  \\begin{array}{cccc}\n    1 & x_{1,1} & \\ldots & x_{1,P} \\\\\n    \\vdots & \\vdots & & \\vdots \\\\\n    1 & x_{i,1} & \\ldots & x_{i,P} \\\\\n    \\vdots & \\vdots & & \\vdots \\\\\n    1 & x_{N,1} & \\ldots & x_{N,P}\n  \\end{array}\n\\right],\n\\boldsymbol{\\beta}=\\left[\n  \\begin{array}{c} \\beta_0 \\\\ \\beta_1 \\\\ \\vdots \\\\ \\beta_P \\end{array}\n\\right],\n\\mathbf{Z}=\\left[\n  \\begin{array}{ccc}z_{1,1}&\\ldots&z_{1, R}\\\\\\vdots&&\\vdots\\\\z_{N,1}&\\ldots&z_{N,R}\\end{array}\n\\right], \n\\mathbf{u}^\\text{run}=\\left[\n  \\begin{array}{c} u^\\text{run}_1 \\\\\\vdots\\\\ u^\\text{run}_{r} \\\\\\vdots\\\\ u^\\text{run}_{R}\\end{array}\n\\right]\n$$ \n\nHence, with the mixed model, the variance covariance matrix of the\nintensities becomes\n\n$$\n\\begin{array}{rcl}\n\\boldsymbol{\\Sigma}_\\mathbf{Y} &=& \\text{var}\\left(\\mathbf{Y}\\right) \\\\\n&=& \\text{var}\\left(\\mathbf{X}\\boldsymbol{\\beta} + \\mathbf{Zu} + \\boldsymbol{\\epsilon}\\right) \\\\\n&=& \\mathbf{Z}\\text{var}\\left(\\mathbf{u}\\right)\\mathbf{Z}^T + \\mathbf{I}\\sigma_\\epsilon^2\\\\\n&=& \\mathbf{Z}\\mathbf{Z}^T\\sigma^2_\\text{run} + \\mathbf{I}\\sigma_\\epsilon^2\n\\end{array}\n$$\n\nSo, we see that the correlation of the data from the same run\nare correctly addressed and that the data from distinct runs are\nassumed to be independent. Hence, the variance-covariance matrix of\n$\\mathbf{Y}$ has a block diagonal structure, with as variance\n$\\sigma^2_\\text{run} + \\sigma_\\epsilon^2$ and the covariance between\nintensities from the same run equals $\\sigma^2_\\text{run}$.\nSuppose every run contains three samples, then\n\n$$\n\\boldsymbol{\\Sigma}_\\mathbf{Y} = \\left[\n\\begin{array}{cccccccccc}\\sigma^2_\\text{run}+\\sigma^2_\\epsilon&\\sigma^2_\\text{run}&\\sigma^2_\\text{run}&0&0&0&\\ldots&0&0&0\\\\\n\\sigma^2_\\text{run}&\\sigma^2_\\text{run}+\\sigma^2_\\epsilon&\\sigma^2_\\text{run}&0&0&0&\\ldots&0&0&0\\\\\n\\sigma^2_\\text{run}&\\sigma^2_\\text{run}&\\sigma^2_\\text{run}+\\sigma^2_\\epsilon&0&0&0&\\ldots&0&0&0\\\\\n0&0&0&\\sigma^2_\\text{run}+\\sigma^2_\\epsilon&\\sigma^2_\\text{run}&\\sigma^2_\\text{run}&\\ldots&0&0&0\\\\\n0&0&0&\\sigma^2_\\text{run}&\\sigma^2_\\text{run}+\\sigma^2_\\epsilon&\\sigma^2_\\text{run}&\\ldots&0&0&0\\\\\n0&0&0&\\sigma^2_\\text{run}&\\sigma^2_\\text{run}&\\sigma^2_\\text{run}+\\sigma^2_\\epsilon&\\ldots&0&0&0\\\\\n\\ldots & \\ldots & \\ldots & \\ldots & \\ldots & \\ldots & \\ldots & \\ldots & \\ldots & \\ldots \\\\\n0&0&0&0&0&0&\\dots&\\sigma^2_\\text{run}+\\sigma^2_\\epsilon&\\sigma^2_\\text{run}&\\sigma^2_u\\\\\n0&0&0&0&0&0&\\dots&\\sigma^2_\\text{run}&\\sigma^2_\\text{run}+\\sigma^2_\\epsilon&\\sigma^2_\\text{run}\\\\\n0&0&0&0&0&0&\\dots&\\sigma^2_\\text{run}&\\sigma^2_\\text{run}&\\sigma^2_\\text{run}+\\sigma^2_\\epsilon\\\\\n\\end{array}\\right]\n$$\n\nThis translates in the following code:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# spikein <- msqrob(\n#     spikein,  i = \"proteins\",\n#     formula = ~ Condition + ## fixed effect for experimental condition\n#         (1 | Run), ## random effect for MS run\n#     robust = TRUE, ridge = TRUE\n# )\n```\n:::\n\n\nThis model is still incomplete and is not executed as we still need to \naccount that multiple samples are acquired within the same run thanks to TMT labelling.\n\n### Effect of TMT label\n\nAcquiring multiple samples in a single run is possible because the\npeptides from each samples are labelled with chemical tags^[Recall the\n[section above](#sec-tmt_workflow)).]. Peptide labelling can introduce\nlabel-specific effects that also need to be modelled. In principle,\nthe effect of adding a chemical label to a peptide should be\nreproducible from experiment to experiment, and hence could be\nmodelled using a fixed effect (given that TMT label swaps are\nperformed so as to avoid confounding between label and treatment).\nHowever, TMT aliquotes contain impurities during production and\nthese impurities may lead to unreproducible effects. Hence, we also\ninclude a random effect to account for labelling effects, i.e.\n$u^\\text{label}_l \\sim N(0, \\sigma^{2,\\text{label}})$. The model thus\nextends to:\n\n$$\ny_{rl} =\n\\mathbf{x}^T_{rl} \\boldsymbol{\\beta} +\nu_r^\\text{run} + u_l^\\text{label} + \\epsilon_{rlm}\n$$\nwith $y_{rl}$ the normalised $\\log_2$ protein intensities in run $r$,\nlabelled with TMT $l$, $u_l^\\text{label}$ the effect introduced by\nlabel $l$.  Note that the $rl$ indexing is similar to the previous $i$\nindexing, but we now explicitly define the observational unit as the\nsample that has been measured in run $r$ and labelled with label $l$.\n\nSpecifying label as a random effect translates in the following code:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# spikein <- msqrob(\n#     spikein,  i = \"proteins\",\n#     formula = ~ Condition + ## fixed effect for experimental condition\n#         (1 | Run) + ## random effect for MS run\n#         (1 | Label), ## random effect for label\n#     robust = TRUE, ridge = TRUE\n# )\n```\n:::\n\n\nThis model is still incomplete and is not executed as we still need to \naccount that each mixture has been replicated three times.\n\n### Effect of replication{#sec-tmt_protein_model}\n\nSome experiments also include technical replication where a TMT\nmixture can be acquired multiple times. This again will induce\ncorrelation. Indeed, protein intensities from the same mixture will be\nmore alike than those of different mixtures. Hence, we also include a\nrandom effect to account for this pseudo-replication, i.e.\n$u^\\text{mix}_m \\sim N(0, \\sigma^{2,\\text{mix}})$. The model thus\nextends to:\n\n$$\ny_{rlm} =\n\\mathbf{x}^T_{rlm} \\boldsymbol{\\beta} +\nu_r^\\text{run} + u_l^\\text{label} + u_m^\\text{mix} + \\epsilon_{rlm}\n$$\n\nwith $y_{rm}$ the normalised $\\log_2$ protein intensities in run $r$\nwith label $l$ in mixture $m$, $u_m^\\text{mix}$ the effect introduced by\nmixture $m$. \n\nThe model translates to the following code:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nspikein <- msqrob(\n    spikein,  i = \"proteins\",\n    formula = ~ Condition + ## fixed effect for experimental condition\n      (1 | Run) + ## random effect for MS run\n      (1 | Label) + ## random effect for label\n      (1 | Mixture), ## random effect for mixture\n    robust = TRUE, ridge = TRUE,\n    overwrite = TRUE\n)\n```\n:::\n\n\nThis model provides a sensible representation of the sources of\nvariation in the data if we were to model the data at the protein\nlevel. This time, we executed the code and will use the result in a\nlater section.  However, we found that modelling protein-level effects\nfrom ion-level data leads to improved performance [@Vandenbulcke2025-sj]. This will require\nan additional model expansion.\n\n### Ion-level modelling{#sec-tmt_ion_model}\n\nEstimating the treatment effect from ion-level data will again induce\nadditional levels of correlation. Indeed, the intensities for the\ndifferent reporter ions in a TMT run within the same spectrum (PSM)\nwill be more similar than the intensities between PSMs. We therefore\nneed to add a random effect term to account for the within PSM\ncorrelation structure, i.e. $u^\\text{PSM}_{rp} \\sim\nN(0,\\sigma^{2,\\text{PSM}})$. Moreover, in each label of a run multiple\nPSM intensities are picked up for each protein. Hence, intensities\nfrom different PSMs for a protein in the same label of a run will be\nmore alike than intensities of different PSMs for the same protein\nbetween labels of runs, and we will address this correlation with a\nlabel-specific random effect nested in run, i.e. $u_{rl}^{label} \\sim\nN(0,\\sigma^{2,\\text{label}})$. The model then becomes:\n\n$$\ny_{rlmp} =\n\\mathbf{x}^T_{rlmp} \\beta + u_r^\\text{run} + u_{l}^\\text{label} +\nu_m^\\text{mix}  +\nu_{rl}^\\text{label} + u_{rp}^\\text{PSM} + \\epsilon_{rlmp}\n$$\nwith $y_{rlmp}$ the $\\log_2$-normalised PSM intensities for run $r$\nwith label $l$ in mixture $m$ and peptide ion $p$. Note, that the\npeptide ion random effect is also nested within each run since each\nspectrum is described by run-specific characteristics.\n\n`msqrobAggregate()`enables the fitting of an ion-level model to obtain\nprotein-level estimates. The function behaves similarly to `msqrob()`\nand shares most of the arguments. The notable difference is the `fcol`\nargument that tells the function how to group the ion-level data into\nprotein-level data. Here, we will group ions by the\n`Protein.Accessions`. The results will be stored in a new\nprotein-level set, which we call `proteins_msqrob`.\n`msqrobAggregate()` will fetch annotations from the `colData` (i.e.\n`\"Condition\"`, `\"Label\"`, `\"Run\"`, `\"Mixture\"`), but contrarily to\n`msqrob()`, it can also fetch anntations from the `rowData` (i.e.\n`\"ionID\"`).\n\n\n::: {.cell}\n\n```{.r .cell-code}\nspikein <- msqrobAggregate(\n    spikein,  i = \"ions\",\n    formula = ~ Condition + ## fixed effect for experimental condition\n        (1 | Label) + ## random effect for label\n        (1 | Run) + ## random effect for Run\n        (1 | Mixture) + ## random effect for mixture\n        (1 | Run:Label) + ## random effect for label nested in run\n        (1 | Run:ionID), ## random effect for ion nested in run\n    fcol = \"Protein.Accessions\",\n    name = \"proteins_msqrob\",\n    robust = TRUE, ridge = TRUE\n)\n```\n:::\n\n\nSo, we built the model shown at the beginning of this section,\neffectively accounting for all sources of variation in TMT-based\nproteomics data.\n\n### Why robust regression?{#sec-robust}\n\nThroughout this book, we estimate the model parameters using robust\nregression through M-estimation (`robust = TRUE`). This class of\nestimation does not need the assumption that the residuals $\\epsilon$\nare normally distributed. However, if the residuals are normal, the\nM-estimators have a high efficiency.\n\nIn ordinary least squares (OLS), the loss function that is minimised\nis:\n\n$$\n\\sum\\limits_{i = 1}^n \\left(y_i - \\mathbf{x}_i^T \\boldsymbol{\\beta}\\right)^2\n$$\n\nWhile the M-estimation minimises the following loss function:\n\n$$\n\\sum\\limits_{i = 1}^n \\rho \\left(y_i - \\mathbf{x}_i^T \\boldsymbol{\\beta}\\right)\n$$\n\nwhere $\\rho(z)$ is a symmetric function with a minimum at $\\rho(0) =\n0$ and increases as $|z|$ increases. So the robust regression through\nM-estimation minimises the maximal bias of the estimators as the \nderivative of $\\rho$ is bounded. A popular function for robust\nregression (and which is used by `msqrob2`) is the Huber function:\n\n$$\n\\rho(e) = \\left\\{\n\\begin{array}{cl}\ne^2 / 2, & \\text{if}\\ |e| \\leq k  \\\\\nk (|e| - k/2), & \\text{if}\\ |e| \\gt k  \\\\\n\\end{array}\n\\right.\n$$\nwhere $k$ is a tuning constant (defaults to $k = 1.345$)\n\nThe estimation is performed using iteratively reweighted least square, i.e. \n\n$$\n\\sum\\limits_{i = 1}^n w_i\\left(y_i - \\mathbf{x}_i^T \\boldsymbol{\\beta}\\right)^2\n$$\nwhere the weigths $w_i$ for each iteration are defined for each data point \nusing the function : \n\n$$\nw(e) = \\left\\{\n\\begin{array}{cl}\n1, & \\text{if}\\ |e| \\leq k  \\\\\n\\frac{k}{|e|}, & \\text{if}\\ |e| \\gt k  \\\\\n\\end{array}\n\\right.\n$$\n\nIntuitively, observations for which the fitting error (absolute\nresidual) is smaller than the constant $k$ will contribute contribute\nto the fitting as for the OLS, while the contribution of the remaining\nobservations will decrease linearly as the error exceeds $k$. This\nmeans that a strong **outlier**, i.e. an observation for which the\nfitting error is large, will barely contribute to the fit. Since the\nlast iteration upon covergence is still a weighted least square\nestimation, we can use the same statistical testing framework as for\nOLS, although the tests and confidence intervals are based on\nasymptotic theory.\n\nNote, that robust regression also extends to linear mixed models, by adopting weighted maximum likelihood e.g. **TODO** ref https://www.tandfonline.com/doi/abs/10.1080/03610920802677216.\n\n### Why ridge regression?{#sec-ridge}\n\n`msqrob2` also allows for ridge regression (when `ridge = TRUE`). In ridge regression, model parameters are estimated by minimising a \npenalised version of the OLS loss:\n\n$$\n\\sum\\limits_{i = 1}^n \\left(y_i - \\mathbf{x}_i^T \\boldsymbol{\\beta}\\right)^2 + \\lambda \\boldsymbol{\\beta}^T\\mathbf{D}\\boldsymbol{\\beta},\n$$\nwith $\\mathbf{D}$ a diagonal matrix that include a 1 on the diagonal elements for the model parameters that are penalised and a 0 otherwise. \n\nNote, that in msqrob2 we leave the intercept $\\beta_0$ unpenalised so the first diagonal element of $\\mathbf{D}$ is set at zero and we only penalise the remaining $m-1$ slope parameters $\\boldsymbol{\\beta}_s=[\\beta_1 \\ldots \\beta_{m-1}]^T$. Hence, \n$\\boldsymbol{\\beta}^T\\mathbf{D}\\boldsymbol{\\beta}$ reduces to the  squared L2 norm of\n$\\boldsymbol{\\beta}_s$, i.e. $||\\boldsymbol{\\beta}_s||_2^2 =\n\\sum\\limits_{j = 1}^{m-1} \\beta_j^2$. \n\nDue to the penality term in the loss function, the estimates of penalised slope terms $\\boldsymbol{\\beta}_s$ will be\nshrunken towards zero, especially for irrelevant covariates in\n$\\mathbf{X}$. In other words, the parameters are stabilised by \nreducing the variance of the estimation, which prevents overfitting. Note, that the penalty term in the loss\nfunction thus implies that the estimates of $\\boldsymbol{\\beta}$ will be biased towards zero. This is known as the variance-bias trade-off. In our experience, msqrob's ridge regression mainly shrinks the log2-fold change estimates ($\\beta$) for features with low evidence for differential abundance to zero while leaving those for features with high evidence for differential abundance largely unaltered.\n\nInterestingly, there exists a link between Bayesian regression, ridge regression and mixed models, i.e. the ridge regression can be adopted by placing a normal prior on the slope terms that have to be penalised, i.e. $\\beta_j \\sim N(0,\\sigma_\\beta^2)$ for $j= 1 \\ldots m-1$. It can than be shown that the best linear unbiased predictor from the linear mixed model with the slope terms defined as random effects provides the ridge regression estimates with a ridge penalty $\\lambda = \\hat{\\sigma}^2_\\epsilon/\\hat{\\sigma}^2_\\beta$). Hence, mixed model software can be used to tune the ridge penalty in a data driven way.\nNote, that this comes at price of increased computational complexity. msqrob2 estimation with ridge regression will thus be slower than without ridge regression. \n\nAlso note, that ridge regression cannot be performed when $\\mathbf{X}$ \ncontains an intercept and a single covariate. Indeed, based on a single slope term the random effect variance $\\sigma^2_\\beta$ cannot be estimated. We demonstrate this by\nintentionally triggering an error after subsetting only spike-in\ncondition `1` and `0.5`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nspikeinSubset <- subsetByColData(spikein, spikein$Condition %in% c(\"1\", \"0.5\"))\ntry(msqrobAggregate(\n  spikeinSubset,  i = \"ions\",\n  formula = ~  Condition + ## fixed effect for experimental condition\n    (1 | Label) + ## random effect for label\n    (1 | Run) + ## random effect for Run\n    (1 | Mixture) + ## random effect for mixture\n    (1 | Run:Label) + ## random effect for label nested in run\n    (1 | Run:ionID), ## random effect for ion nested in run\n  fcol = \"Protein.Accessions\",\n  name = \"proteins_msqrob\",\n  robust = TRUE, ridge = TRUE\n))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nError : BiocParallel errors\n  1 remote errors, element index: 1\n  406 unevaluated and other errors\n  first remote error:\nError in (function (y, rowdata = NULL, formula, coldata, doQR, robust, : The mean model must have more than two parameters for ridge regression.\n              if you really want to adopt ridge regression when your factor has only two levels\n              rerun the function with a formula where you drop the intercept. e.g. ~-1+condition\n            \n```\n\n\n:::\n:::\n\n\nAs the error message suggests, either the ridge argument has to be set at FALSE to obtain an unpenalised fit, or the intercept can be suppressed in\norder to obtain a fit with two slope terms (one for each group) so as to enable the estimation of the ridge penalty. \n\n## Statistical inference\n\nWe can now convert the biological question \"does the spike-in\ncondition affect the protein intensities?\" into a statistical\nhypothesis. In other words, we need to translate this question in a null and alternative hypothesis on a single model parameter or a linear combination of model parameters, which is also referred to with a [contrast](#sec-inference).\nWe plot an overview of the model parameters.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(\"ExploreModelMatrix\")\nvd <- VisualizeDesign(\n    sampleData =  colData(spikein),\n    designFormula = ~ Condition,\n    textSizeFitted = 4\n)\nvd$plotlist\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[[1]]\n```\n\n\n:::\n\n::: {.cell-output-display}\n![ ](02-advanced_files/figure-html/advanced_VisualizeDesign-1.png){width=672}\n:::\n:::\n\n\nNote that with ExploreModelMatrix we can only visualise fixed effects\npart of the model. This is fine as the mean protein abundances can\nonly systematically differ from each other according to the\n`Condition` (fixed effect).\n\n### Hypothesis testing\n\nThe average difference in the log2-intensity between the 1x and the 0.5x\nconditions is provided by the contrast `ridgeCondition1 -\nridgeCondition0.5`. This is, however, not the only difference we could\nassess. As described in the [previous\nchapter](#sec-multiple_contrasts), we will generate a contrast matrix\nthat assess all possible pairwise comparisons between spike-in\nconditions.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nallHypotheses <- createPairwiseContrasts(\n  ~ Condition, colData(spikein), \"Condition\", ridge = TRUE\n)\nL <- makeContrast(\n  allHypotheses,\n  parameterNames = paste0(\"ridgeCondition\", c(\"0.5\", \"0.667\", \"1\"))\n)\n```\n:::\n\n\nWe test our null hypotheses using `hypothesisTest()` and the estimated\nion-level model stored in `proteins_msqrob`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nspikein <- hypothesisTest(spikein, i = \"proteins_msqrob\", contrast = L)\ninferences <- rowData(spikein[[\"proteins_msqrob\"]])[, colnames(L)]\n```\n:::\n\n\nWe can retrieve the results for the comparison between the 1x and the\n0.5x conditions.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhead(inferences$\"ridgeCondition1 - ridgeCondition0.5\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n               logFC           se         df             t        pval\nO00151 -2.549859e-02 2.153969e-02  471.97751 -1.183796e+00 0.237089769\nO00220  1.440133e-02 5.774331e-02   94.45995  2.494026e-01 0.803590901\nO00244 -3.706545e-10 5.416412e-06   84.16092 -6.843175e-05 0.999945561\nO00299 -3.154427e-02 1.172633e-02 1380.19537 -2.690038e+00 0.007230547\nO00330 -2.881986e-02 3.682363e-02  193.93129 -7.826456e-01 0.434789869\nO00399            NA           NA         NA            NA          NA\n          adjPval\nO00151 0.58896109\nO00220 1.00000000\nO00244 1.00000000\nO00299 0.03771935\nO00330 0.87236685\nO00399         NA\n```\n\n\n:::\n:::\n\n\nThe last row is filled with missing values because data modelling\nresulted in a `fitError` (we will explore in a [later\nsection](#sec-fiterror) how we can deal with proteins that could not\nbe fit).\n\n### Volcano plots\n\nWe generate volcano plots for all pairwise comparison between \nconditions. First, we add new columns to the tables and join them in a\nsingle table.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ninferences <- lapply(colnames(inferences), function(i) {\n  inference <- inferences[[i]]\n  inference$Protein <- rownames(inference)\n  inference$isUps <- grepl(\"ups\", inference$Protein)\n  inference$Comparison <- gsub(\"ridgeCondition\", \"\", i)\n  inference$Comparison <- gsub(\"^([0-9.]*)$\", \"\\\\1 - 0.125\", inference$Comparison)\n  inference\n})\ninferences <- do.call(rbind, inferences) ## combine in a single table\n```\n:::\n\n\nThen, we plot the volcano plots with each comparison in a separate facet.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(inferences) +\n    aes(x = logFC,\n        y = -log10(pval),\n        color = isUps,\n        shape = adjPval < 0.05) +\n    geom_point() +\n    scale_color_manual(\n      values = c(\"grey20\", \"firebrick\"), name = \"\",\n      labels = c(\"HeLA background\", \"UPS standard\")\n    ) +\n    facet_wrap(~ Comparison, scales = \"free\") +\n    ggtitle(\"Statistical inference for all pairwise comparisons\") \n```\n\n::: {.cell-output-display}\n![ ](02-advanced_files/figure-html/advanced_volcao-1.png){width=672}\n:::\n:::\n\n\n### Fold change distributions\n\nAs this is a spike-in study with known ground truth, we can also plot\nthe log2 fold change distributions against the expected values, in\nthis case 0 for the HeLa proteins and the difference of the log\nconcentration for the spiked-in UPS standards. We first create a small\ntable with the real values.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrealLogFC <- data.frame(Comparison = unique(inferences$Comparison))\nrealLogFC$logFC <- paste0(\"log2(\", gsub(\"-\", \"/\", realLogFC$Comparison), \")\") |> \n  sapply(function(x) eval(parse(text = x)))\n```\n:::\n\n\nWe can now create the boxplots with the estimated log2-fold changes,\nadding horizontal lines with the corresponding target values.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(inferences) +\n    aes(y = logFC,\n        x = isUps,\n        colour = isUps) +\n    geom_boxplot() +\n  \n    scale_color_manual(\n        values = c(\"grey20\", \"firebrick\"), name = \"\",\n        labels = c(\"HeLA background\", \"UPS standard\")\n    ) +\n    geom_hline(data = realLogFC, aes(yintercept = logFC), \n               colour = \"firebrick\") +\n    geom_hline(yintercept = 0) +\n    facet_wrap(~ Comparison) +\n    ggtitle(\"Distribution of the log2 fold changes\")\n```\n\n::: {.cell-output-display}\n![ ](02-advanced_files/figure-html/advanced_boxplot-1.png){width=672}\n:::\n:::\n\n\nEstimated log2 fold change for HeLa proteins are closely distributed\naround 0, as expected. log2 fold changes for UPS standard proteins are\nbiased towards zero probably due to ratio compression effects, as reported\npreviously for labeled strategies [@Savitski2011-qi].\n\n### Detail plots\n\nWe can explore the PSM intensities for a protein to validate the\nstatistical inference results. For example, let's explore the\nintensities for the protein with the most significant difference.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n(targetProtein <- inferences$Protein[which.min(inferences$adjPval)])\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"P02788ups\"\n```\n\n\n:::\n:::\n\n\nTo obtain the required data, we perform a [data manipulation\npipeline](#sec-detail_plot). We plot the log2 normalised intensities\nfor each sample. Since the protein is modelled at the peptide ion\nlevel, multiple ion intensities are recorded in each sample. Each ion\nis linked across samples using a grey line. Samples are colored\naccording to UPS spike-in condition. Finally, we split the plot in\nfacets, one for each mixture, to visualise the heterogeneity induced\nby sample preparation.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nspikein[targetProtein, , \"ions\"] |>\n    longForm(colvars = colnames(colData(spikein)),\n             rowvars = c(\"Protein.Accessions\", \"ionID\")) |>\n    data.frame() |>\n    ## We reorder the sample identifiers to improve visualisation\n    mutate(colname = factor(colname, levels = unique(colname[order(Condition)]))) |> \n    ggplot() +\n    aes(x = colname,\n        y = value) +\n    geom_line(aes(group = ionID), linewidth = 0.1) +\n    geom_point(aes(colour = Condition)) +\n    facet_grid(~ Mixture, scales = \"free\") +\n    ggtitle(targetProtein) +\n    theme_minimal() +\n    theme(axis.text.x = element_blank())\n```\n\n::: {.cell-output-display}\n![ ](02-advanced_files/figure-html/advanced_detail_plot-1.png){width=960}\n:::\n:::\n\n\n## Protein-level inference\n\nWe here show how to perform a two-step approach, where the data are \nfirst summarised then modelled. We perform the same statistical\nworkflow as above, but starting from the protein level model estimated\nin [the section above](#sec-tmt_protein_model)^[Note that the contrasts remain the same, as the fixed effect part of the model (spike-in treatment effect)is the same for the models estimated with\n`msqrob()` or `msqrobAggregate()`, so we do not need to build a new \ncontrast matrix.].\n\n\n::: {.cell}\n\n```{.r .cell-code}\nspikein <- hypothesisTest(spikein, i = \"proteins\", contrast = L)\ninferences <- rowData(spikein[[\"proteins\"]])[, colnames(L)]\n```\n:::\n\n\nWe build the volcano using the same code as above:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ninferences <- lapply(colnames(inferences), function(i) {\n  inference <- inferences[[i]]\n  inference$Protein <- rownames(inference)\n  inference$isUps <- grepl(\"ups\", inference$Protein)\n  inference$Comparison <- gsub(\"ridgeCondition\", \"\", i)\n  inference\n})\ninferences <- do.call(rbind, inferences) ## combine in a single table\nggplot(inferences) +\n    aes(x = logFC,\n        y = -log10(pval),\n        color = isUps) +\n    geom_point() +\n    geom_hline(yintercept = -log10(0.05)) +\n    scale_color_manual(\n      values = c(\"grey20\", \"firebrick\"), name = \"\",\n      labels = c(\"HeLA background\", \"UPS standard\")\n    ) +\n    facet_wrap(~ Comparison, scales = \"free\") +\n    ggtitle(\"Statistical inference for all pairwise comparisons\",\n            subtitle = \"Protein-level modelling\") \n```\n\n::: {.cell-output-display}\n![ ](02-advanced_files/figure-html/advanced_volcano_proteins-1.png){width=672}\n:::\n:::\n\n\nWe plot the fold change distributions:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(inferences) +\n    aes(y = logFC,\n        x = isUps,\n        colour = isUps) +\n    geom_boxplot() +\n    geom_point( ## Adding the expected Log2 fold changes \n        data = group_by(inferences, Comparison, isUps) |> \n          summarise(logFC = ifelse(isUps, log2(eval(parse(text = sub(\"-\", \"/\", Comparison)))), 0)),\n        shape = 10, size = 4\n    ) +\n    scale_color_manual(\n        values = c(\"grey20\", \"firebrick\"), name = \"\",\n        labels = c(\"HeLA background\", \"UPS standard\")\n    ) +\n    facet_wrap(~ Comparison) +\n    ggtitle(\"Distribution of the log2 fold changes\",\n            subtitle = \"Protein-level modelling\") \n```\n\n::: {.cell-output-display}\n![ ](02-advanced_files/figure-html/advanced_boxplot_proteins-1.png){width=672}\n:::\n:::\n\n\nExploring the intensities at the protein level is simplified compared\nto PSM-level exploration since every sample now contains a single\nobservation, the protein intensity.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nspikein[targetProtein, , \"proteins\"] |>\n    longForm(colvars = colnames(colData(spikein))) |>\n    data.frame() |>\n    ## We reorder the sample identifiers to improve visualisation\n    mutate(colname = factor(colname, levels = unique(colname[order(Condition)]))) |> \n    ggplot() +\n    aes(x = colname,\n        y = value) +\n    geom_point(aes(colour = Condition)) +\n    facet_grid(~ Mixture, scales = \"free\") +\n    ggtitle(targetProtein,\n            subtitle = \"Summarised protein data\") +\n    theme_minimal() +\n    theme(axis.text.x = element_blank())\n```\n\n::: {.cell-output-display}\n![ ](02-advanced_files/figure-html/advanced_detail_plot_proteins-1.png){width=960}\n:::\n:::\n\n\nNotice how the summarisation-based approach hides the variation\nassociated with the measurement of different peptide ions within the\nsame protein, as well as discrepancies between peptide identification\nrates across mixtures.\n\n## Dealing with `fitErrors`{#sec-fiterror}\n\nMissing value patterns in the data may lead to non-estimable\nparameters. This is recognised by `msqrob2` and will lead to\n`fitError`s which is a type of model output where the model could not\nbe fit. This information is available from the `StatModel` objects.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrowData(spikein[[\"proteins_msqrob\"]])[[\"msqrobModels\"]] |>\n    sapply(function(x) x@type) |>\n    table()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n\nfitError     lmer \n      94      313 \n```\n\n\n:::\n:::\n\n\nThere are 3 possible strategies for dealing with these `fitErrors`.\n\n### Removing the random effect of sample{#sec-msqrob_refit}\n\nThis strategy only applies for PSM-level models. Some proteins are\ndifficult to detect and may be quantified by a single peptide ion\nspecies. In these cases, every sample contains a single observation\nfor the protein and hence no random effect of `Run:Label` can be\nestimated. While the results for such one-hit wonders are\nquestionable, we provide `msqrobRefit()` to refit a new model for a\nsubset of proteins of interest.\n\nIn this case, we want to refit a model without a sample effect for\none-hit-wonder proteins. This information can be retrieved from the\naggregation results, using `aggcounts()`. This getter function\nprovides the number of features used when performing summarisation for\neach protein in each sample.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncounts <- aggcounts(spikein[[\"proteins_msqrob\"]])\ncounts[1:5, 1:5]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n       161117_SILAC_HeLa_UPS1_TMT10_Mixture1_01.raw_Abundance..127N\nO00151                                                            4\nO00220                                                            1\nO00244                                                            0\nO00299                                                           15\nO00330                                                            2\n       161117_SILAC_HeLa_UPS1_TMT10_Mixture1_01.raw_Abundance..127C\nO00151                                                            4\nO00220                                                            2\nO00244                                                            0\nO00299                                                           15\nO00330                                                            2\n       161117_SILAC_HeLa_UPS1_TMT10_Mixture1_01.raw_Abundance..128N\nO00151                                                            4\nO00220                                                            2\nO00244                                                            0\nO00299                                                           15\nO00330                                                            2\n       161117_SILAC_HeLa_UPS1_TMT10_Mixture1_01.raw_Abundance..128C\nO00151                                                            4\nO00220                                                            1\nO00244                                                            0\nO00299                                                           15\nO00330                                                            2\n       161117_SILAC_HeLa_UPS1_TMT10_Mixture1_01.raw_Abundance..129N\nO00151                                                            4\nO00220                                                            2\nO00244                                                            0\nO00299                                                           15\nO00330                                                            2\n```\n\n\n:::\n:::\n\n\nOne-hit wonder proteins are proteins for which the number of feature\nused for summarisation does not exceed 1 peptide ion across samples.\n\n\n::: {.cell}\n\n```{.r .cell-code}\noneHitProteins <- rownames(counts)[rowMax(counts) == 1]\n```\n:::\n\n\nUsing `msqrobRefit()` is very similar to `msqrobAggregate()`, see here\nhowever that we adapted the formula to remove the random effect for\nlabel nested within run. We also mention which proteins must be\nrefit using the `subset` argument.\n\n**TODO**: include msqrobRefit in `msqrob2`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nspikein <- msqrobRefit(\n    spikein, i = \"ions\",\n    subset = oneHitProteins,\n    formula = ~ Condition + ## fixed effect for experimental condition\n        (1 | Label) + ## fixed effect for label\n        (1 | Mixture) + ## random effect for mixture\n        (1 | Run ) + ## random effect for run\n        (1 | Run:ionID), ## random effect for PSM nested in MS run\n        ## random effect for label nested in run has been removed\n    fcol = \"Protein.Accessions\",\n    name = \"proteins_msqrob\",\n    robust = TRUE, ridge = TRUE\n)\n```\n:::\n\n\nLet's see how removing the random effect of label within run for\none-hit-wonder proteins reduced the number of `fitError`s.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfitTypes <- rowData(spikein[[\"proteins_msqrob\"]])[[\"msqrobModels\"]] |>\n    sapply(function(x) x@type)\ntable(fitTypes)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nfitTypes\nfitError     lmer \n       1      406 \n```\n\n\n:::\n:::\n\n\n### Manual inspection\n\nOne protein is still non-estimable upon refitting and requires\nadditional data exploration to understand why the model cannot be\nestimated. Let us take the protein that cannot be fitted.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nproteinError <- names(fitTypes[fitTypes == \"fitError\"])[[1]]\n```\n:::\n\n\nTo understand the problem, we plot the data for that protein using the\nsame `QFeatures` pipeline described above. We here plot the data in\nfunction of the `Label` (x-axis), `Condition` (colour) and `Mixture`\n(shape).\n\n\n::: {.cell}\n\n```{.r .cell-code}\nspikein[proteinError, , \"ions\"] |>\n    longForm(colvars = colnames(colData(spikein)),\n               rowvars = c(\"Protein.Accessions\", \"ionID\")) |>\n    data.frame() |>\n    mutate(colname = factor(colname, levels = unique(colname[order(Condition)]))) |> \n    ggplot() +\n    aes(x = colname,\n        y = value) +\n    geom_point(aes(colour = Condition)) +\n    facet_grid(~ Mixture, scales = \"free\") +\n    ggtitle(targetProtein) +\n    theme_minimal() +\n    theme(axis.text.x = element_blank())\n```\n\n::: {.cell-output-display}\n![ ](02-advanced_files/figure-html/advanced_fiterror_manual-1.png){width=672}\n:::\n:::\n\n\nWe can immediately spot that PSM intensities are only present in\nmixture 3. Hence, the mixed model cannot be fitted with a random\neffect for mixture. However, we don't want to rely on a result that \nhas been measured in a single replicate and `msqrob2` flags these\nproblematic proteins instead of defining ad-hoc heuristics, avoiding\npotentially misleading conclusions. \n\n### Imputation\n\nThe last popular strategy to deal with fit errors is to impute missing values\nso that all models can be estimated. \nNote, that our general advice is to avoid imputation as this typically comes at the expense of additional and often unrealistic\nassumptions^[Indeed, we have shown that state-of-the-art imputation methods profoundly change the\ndistribution of the intensities in bulk proteomics, which can have a detrimental impact on the downstream analysis. \nOur take is to start from the ion or peptide intensity data as is and to model the data from the same protein together while correcting for ion/peptide species. \nThese ion/peptide-level models can either be used to directly infer differential abundance at the protein level or to obtain protein-level abundance values in the summarisation step. Note, that this approach assumes random missingness upon correction for ion/peptide species.].\n\n`QFeatures` provides a large\npanel of imputation strategies through `impute()`. \nIdentifying which\nimputation strategy is most suited for this data set is outside the\nscope of this book. \nFor illustration purposes, we here arbitrarily use KNN\nimputation.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n(spikein <- impute(\n    spikein, i = \"ions\", name = \"ions_imputed\",\n    method = \"knn\", colmax = 1\n))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nAn instance of class QFeatures (type: bulk) with 64 sets:\n\n [1] Mixture1_01: SummarizedExperiment with 1719 rows and 8 columns \n [2] Mixture1_02: SummarizedExperiment with 1722 rows and 8 columns \n [3] Mixture1_03: SummarizedExperiment with 1776 rows and 8 columns \n ...\n [62] proteins: SummarizedExperiment with 407 rows and 120 columns \n [63] proteins_msqrob: SummarizedExperiment with 407 rows and 120 columns \n [64] ions_imputed: SummarizedExperiment with 4066 rows and 120 columns \n```\n\n\n:::\n:::\n\n\nThe function added a new set `ions_imputed` which we can use to fit\nthe ion-level model.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nspikein <- msqrobAggregate(\n    spikein,  i = \"ions_imputed\",\n    formula = ~ Condition + ## fixed effect for experimental condition\n        (1 | Label) + ## random effect for label\n        (1 | Mixture) + ## random effect for mixture\n        (1 | Run) + ## random effect for run\n        (1 | Run:Label) + ## random effect for PSMs from the same protein in a label of a run\n        (1 | Run:ionID), ## random effect for ions in the same spectrum of an MS run\n    fcol = \"Protein.Accessions\",\n    modelColumnName = \"msqrob_psm_rrilmm\",\n    name = \"proteins_msqrob_imputed\",\n    robust = TRUE, ridge = TRUE\n)\n```\n:::\n\n\nWe here assess how many models have been estimated for all proteins\nupon imputation.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrowData(spikein[[\"proteins_msqrob_imputed\"]])[[\"msqrob_psm_rrilmm\"]] |>\n    sapply(function(x) x@type) |>\n    table()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n\nfitError     lmer \n      59      348 \n```\n\n\n:::\n:::\n\n\nAgain `fitError`s were generated for one-hit-wonder proteins.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncounts <- aggcounts(spikein[[\"proteins_msqrob_imputed\"]])\noneHitProteins <- rownames(counts)[rowMax(counts) == 1]\nspikein <- msqrobRefit(\n    spikein, i = \"ions_imputed\",\n    subset = oneHitProteins,\n    formula = ~ Condition + ## fixed effect for experimental condition\n        (1 | Label) + ## random effect for label\n        (1 | Mixture) + ## random effect for mixture\n        (1 | Run ) + ## random effect for run\n        (1 | Run:ionID), ## random effect for PSM nested in MS run\n        ## random effect for label nested in run has been removed\n    fcol = \"Protein.Accessions\",\n    modelColumnName = \"msqrob_psm_rrilmm\",\n    name = \"proteins_msqrob_imputed\",\n    robust = TRUE, ridge = TRUE\n)\nrowData(spikein[[\"proteins_msqrob_imputed\"]])[[\"msqrob_psm_rrilmm\"]] |>\n    sapply(function(x) x@type) |>\n    table()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n\nlmer \n 407 \n```\n\n\n:::\n:::\n\n\nUpon refit, no `fitError`s were generated for any proteins, as\nexpected. Be mindful that the results upon imputation will be highly\ndepended on the suitability of the imputation approach.\n\n## Conclusion\n\nIn this chapter, we expanded upon the basic concepts with a more\ncomplex analysis. First, we started our analysis from PSM-level data,\nshowing that our tools are amenable to read different levels of input\nformat such as the [peptides table](#sec-peptide_table) or the\n[PSM table](#sec-psm_table). Starting from the PSM level data\nalso enabled better control of the PSM filtering compared to starting\nwith peptide-level data. We demonstrated how to conduct a\ncomprehensive feature filtering workflow, with different level of\ncustomisation to enable filtering based on any criterion.\n\nThe complexity of the analysis is the reflection of the complexity of\nthe experimental designs, as TMT-labelling includes the modelling of\nseveral additional sources of variation compared to LFQ experiments:\neffect of treatment of interest, effect of TMT labelling, effect of\nthe MS acquisition run, and the effect of replication. We built\nprotein-level models, but we have also shown that we can build\nPSM-level models if we also include a spectrum effect and an effect\nfor TMT label nested within run.\n\nFinally, we have demonstrated how to deal with proteins that cannot be\nmodelled due to missing values. For PSM-level models, we can remove\nthe random effects for TMT label within run that cannot be estimated for\none-hit-wonder proteins. We can also manually inspect how missing\nvalues can influence the model design, and refit a simplified model\nupon expert's intervention. Finally, we can impute missing values,\nwhich unlocks model fitting, but imposes strong assumption on the\nvalidity of the imputation approach and the reliability of the\npredicted values.\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}